---
layout: single
title:  "15.Object-Oriented Programming (OOP)"
category: "Python"
tag: [Python]
header:
  teaser: #../images/2025-07-08-CT_6/image-20250708184503610.png
toc: true
toc_sticky: true
toc_label: CONTENTS
toc_icon: "fa-solid fa-seedling" # More icons: https://fontawesome.com/v6/search?ic=free
author_profile: false
sidebar:
    nav: "counts"
search: true # Change true to false if you don't want to have this article be searched 
redirect_from:
    - /Python/Python_15
use_math: true
---

**[Reference]** <br>
$\bullet$ [홍정모의 파이썬 프로그래밍 추월코스](https://www.honglab.ai/courses/python)<br>
This post is written based on above lecture.<br>
All contents in this post are not the same with above lecture.<br>
Please show the detail at the his lecture.
{: .notice--success}

# Introduction
{% include start-box.html class="math-box"%}
Python is an **Object-Oriented Programming (OOP)** language. 
OOP is a methodology for structuring programs by using objects.

An object bundles together functions (methods) and the data required for those functions to work. 
This helps make it easier to build larger, more complex programs.

An object bundles behaviors (what it can do) and the data needed to perform those behaviors. 
More specifically, it includes the functions that define the behaviors and the variables that hold the data.

Objects are said to be encapsulated, meaning they wrap up their data and behaviors. 
This allows the programmer to use the object without needing to worry about all of its internal details.
{% include end-box.html %}

# 1. OOP (Object-Oriented Programming)
{% include start-box.html class="math-box"%}
We have already used various kinds of objects. 
For example, let's think about the `str` (string) object.

- `a` and `b` (or more precisely, the objects associated with the names `a` and `b`) hold the data "hello" and "abc".
- "hello" and "abc" have different values but are the same type, so they can be used in the same way. This shows that well-designed data types are easy to reuse.
- `a` and `b` can also perform actions using methods. For example, both `a` and `b` can use the `.upper()` method to change their data.
- When you want to perform an action, you can simply use `.upper()` to "make this uppercase" without caring what specific data is inside `a` or `b`.

```python
a = str("hello")
b = str("abc")

print(type(a), type(b))  # <class 'str'> <class 'str'>

a.upper(), b.upper() # 'HELLO', 'ABC'
```
```python
<class 'str'> <class 'str'>

('HELLO', 'ABC')
```

Here are some advantages of OOP:

- You don't need to know the internal details.
- It's easy to reuse well-designed data types.
- You can design the program's structure from an abstract perspective.

Let's summarize the important terms.

- **Object** : In Python, everything is an object. More specifically, it refers to a bundle of data and functionality.
- **Class** : A template that defines what data an object will have and what functions it can perform. In other words, it defines a data type. 
- **Instance** : Since everything in Python is an object, the concept of an object is very important. When you want to emphasize that an object was created according to a specific class, you call that object an instance of that class. : For example, in `a = str("hello")`, `a` is an instance of the `str` class. : "Object" and "instance" are often used interchangeably.
- **Attribute** : The components that make up a class are called attributes. In Python, anything that can be used by placing a dot (`.`) after a variable is called an attribute.
- **Data Attribute** : Refers to the variables that are part of an object (or class).
- **Method** : Refers to the functions that belong to an object (or class).

    Ex) Think of a TV Class<br>
    Data Attributes: Size, Color, Current Channel<br>
    Methods: Turn on/off, Change Channel, Volume Control

To check which class an object is an instance of, you can use the `isinstance()` function.
```python
a = str("hello")
b = str("abc")

# Use isinstance() to check what type of instance an object is.
isinstance(a, str), isinstance(b, str) # (True, True)
```
```python
(True, True)
```
{% include end-box.html %}

# 2. Creating a Data Type with `Class`
{% include start-box.html class="math-box"%}

## 2-1) Creating a Data Type with `Class`
You can create and use your own necessary data types by using the `class` syntax.

[Definition of a Class]
- Class Name
- Methods
- Data Attributes

```
class MyInt:                   
    def __init__(self, value):   
        self.v = value         
                               
    def add(self, a):
        self.v = self.v + a
```

<figure style="display: flex; flex-direction: column; align-items: center; margin-top: 0.5em; margin-bottom: 0.5em;">
  <img src="../images/2025-11-17-Python_15/Fig_1.png" alt="" 
       style="width: 110%; height: auto;">
</figure> 

```python
# Defined using the class keyword
# Use CamelCase for class names
class MyInt:
    # A special method executed automatically when an instance is created
    # Note the two underscores before and after init
    # magic or Dunder (Double UNDERscores) methods
    # Called a constructor in C++ or Java.
    # self is a reference (variable) to the instance
    def __init__(self, value):
        # Define instance variable
        self.value = value

    # Define method (the first parameter is self)
    def add(self, a):
        self.value = self.value + a

    # Define method (the first parameter is self)
    def print(self):
        print(self.value)

# You can create multiple instances.
my_int1 = MyInt(123) # __init__(123)
my_int2 = MyInt(456) # __init__(456)

print(my_int1.value) # 123
my_int1.add(1) # No need to pass self when calling the method.
my_int1.print() # 124

print(my_int2.value) # 456
my_int2.add(1)
my_int2.print() # 457
```
```python
123
124
456
457
```

## 2-2) ID of `self` and Instance
{% include start-box.html class="math-box"%}
The `id` of an object (instance) created from a class is identical to the `id` of `self` when that object (instance) is created. 
Even if you continue to apply the class's methods to it, the `id` remains unchanged.

Furthermore, the object of a class and its instance variables have different IDs. 
In other words, when a new class object is created, the corresponding instance variables for that object are also newly created.

```python
class MyInt:
    def __init__(self, value):
        self.value = value
        # Check the ID of 'self' when initialized
        print(id(self))
        
    def add(self, a):
        self.value = self.value + a
        # Check the ID of 'self' inside a method
        print(id(self))
        
    def print(self):
        print(self.value)
        print(id(self))

# 1. Create two instances
a = MyInt(1)
b = MyInt(2)

# 2. Check values and IDs
print(a.value, b.value)
print(id(a.value), id(b.value))
```
```python
1759240711392
1759240708416
1 2
1759189598448 1759189598480
```

```python
class MyInt:
    def __init__(self, value):
        self.value = value
        print(id(self)) # (Optional: print ID on init)

    def add(self, a):
        self.value = self.value + a
        print(id(self)) # (Optional: print ID on add)

    def print(self):
        print(self.value)
        print(id(self)) # (Optional: print ID on print)

print("id of self of my_int1 before add method")
my_int1 = MyInt(123)
print(id(my_int1)) # Matches the ID of 'self'

print("\nid of my_int1(instance)")
print(id(my_int1))

print("\nid of self.value of my_int1(instance)")
print(id(my_int1.value))

print("\nid of self of my_int2 before add method")
my_int2 = MyInt(1234)
print(id(my_int2))

print("\nid of self.value of my_int2(instance)")
print(id(my_int2.value))

print("\nid of self after add method")
my_int1.add(1)
print(id(my_int1)) # ID remains the same

print("\nid of self after print method")
my_int1.print() # 124
print(id(my_int1)) # ID remains the same

print("\nid of my_int1 after methods")
print(id(my_int1)) # ID remains the same

# Note: The ID of the VALUE (an integer) changes because integers are immutable.
# But the ID of the instance 'my_int1' stays constant.
print()
print(id(my_int1.value))
```
```python
id of self of my_int1 before add method
1528504686992
1528504686992

id of my_int1(instance)
1528504686992

id of self.value of my_int1(instance)
1528427188272

id of self of my_int2 before add method
1528504689728
1528504689728

id of self.value of my_int2(instance)
1528504266032

id of self after add method
1528504686992
1528504686992

id of self after print method
124
1528504686992
1528504686992

id of my_int1 after methods
1528504686992

1528427188304
```
{% include end-box.html %}
{% include end-box.html %}

# 3. Namespace
{% include start-box.html class="math-box"%}

## 3-1) Namespace and `__main__`

When you print the type of an instance created from a class, you often see `__main__` attached to the front. What does this mean?

```python
class MyClass:
    pass # Minimal class definition

# Create an instance of the class
i = MyClass()

print(type(i))
```
```python
<class '__main__.MyClass'>
```

Namespace refers to the space where variables, functions, classes, and other names are stored.
You can use the built-in function `dir()` to check what names are in a specific scope or object. `dir` stands for directory. Let's use it to see what names are in the global scope.

```python
# Run dir() in the Global scope
dir()
```
```python
['In',
 'MyClass',
 'MyInt',
 'Out',
 '_',
 '_1',
 '_2',
 '__',
 '___',
 '__builtin__',
 '__builtins__',
 '__doc__',
 '__loader__',
 '__name__',
 '__package__',
 '__spec__',
 '__vsc_ipynb_file__',
 '_dh',
 '_i',
 '_i1',
 '_i10',
 '_i2',
 '_i3',
 '_i4',
 '_i5',
 '_i6',
 '_i7',
 '_i8',
 '_i9',
 '_ih',
 '_ii',
 '_iii',
 '_oh',
 'a',
 'b',
 'exit',
 'get_ipython',
 'i',
 'my_int1',
 'my_int2',
 'open',
 'quit']
```

When you check the names in the global scope with `dir()`, you can see that `__name__` is present. If you print it, you will see the output `__main__`.

```python
print(__name__)
```
```python
__main__
```

`__name__` tells you the name of the module. 
When `__name__` is `__main__`, it means the script is being run directly by the user, rather than being imported as part of another module.

```python
import numpy as np

print("np.__name__:", np.__name__) # numpy -> original module name

import json

print("json.__name__:", json.__name__) # json

print("__name__:", __name__) # __main__
```
```python
np.__name__: numpy
json.__name__: json
__name__: __main__
```

When you execute a program or script, you are asking the operating system to run it. 
The OS then looks for the entry point of the program or script and starts execution from there. 
The OS needs a starting point to begin the program. 
In other languages, this is usually a function or method named main. 
In those languages, the programmer must write this starting point directly. 
However, Python handles this internally, so there's no need for an explicit main function.

If the current `__name__` namespace is `__main__` (meaning the script was executed directly by the user and not imported as part of a module), you can use the following pattern to intentionally execute a `main()` function:

```python
# Usually used in script mode.

def main():
    # Things you want to do
    print("I am", __name__)

if __name__ == "__main__":
    main()
```
```python
I am __main__
```

## 3-2) Objects and Namespace
In Python, an object itself is also a namespace.

If you create an instance `i` of a class named `MyClass` and inspect its namespace using `dir(i)`, you can see the instance variables and methods defined within the `MyClass` class.
```python
class MyClass:
    
    def __init__(self):
        self.my_variable = "Hello"
        
    def my_method(self):
        pass

# Create an instance
i = MyClass()

print(i.my_variable)
i.my_method()

# Check the namespace of the instance 'i'
dir(i)
```
```python
Hello
['__class__',
 '__delattr__',
 '__dict__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__init_subclass__',
 '__le__',
 '__lt__',
 '__module__',
 '__ne__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 '__weakref__',
 'my_method',
 'my_variable']
```

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Adding Attributes Dynamically**<br>
You can also add new attribute names (variables or methods) to an instance after it has been created. However, even though the syntax allows it, this is generally **not recommended** as good practice.
```python
class EmptyClass:
    pass

    # def __init__(self):
    #     self.my_variable = "Hello"
    
    # def any_method(self):
    #     self.my_variable = "Hello"

e = EmptyClass()

# Adding an instance variable dynamically
e.my_variable = "Hello"
# Compare this to: defining self.my_variable = "Hello" inside a method

# Adding a method dynamically using a lambda
e.my_method = lambda : print("Hi")

# e.my_method()

# Check the namespace
dir(e)
```
```python
['__class__',
 '__delattr__',
 '__dict__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__init_subclass__',
 '__le__',
 '__lt__',
 '__module__',
 '__ne__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 '__weakref__',
 'my_method',
 'my_variable']
```
{% include end-box.html %}

{% include end-box.html %}





















```python

```
```python

```



<div class="indented-paragraph" markdown="1">

</div>

{% include start-box.html class="math-box-inner" font_size="0.8em"%}

```python

```
```python

```
{% include end-box.html %}


{% include start-box.html class="math-box"%}

{% include end-box.html %}