---
layout: single
title:  "15.Object-Oriented Programming (OOP)"
category: "Python"
tag: [Python]
header:
  teaser: #../images/2025-07-08-CT_6/image-20250708184503610.png
toc: true
toc_sticky: true
toc_label: CONTENTS
toc_icon: "fa-solid fa-seedling" # More icons: https://fontawesome.com/v6/search?ic=free
author_profile: false
sidebar:
    nav: "counts"
search: true # Change true to false if you don't want to have this article be searched 
redirect_from:
    - /Python/Python_15
use_math: true
---

**[Reference]** <br>
$\bullet$ [홍정모의 파이썬 프로그래밍 추월코스](https://www.honglab.ai/courses/python)<br>
This post is written based on above lecture.<br>
All contents in this post are not the same with above lecture.<br>
Please show the detail at the his lecture.
{: .notice--success}

# Introduction
{% include start-box.html class="math-box"%}
Python is an **Object-Oriented Programming (OOP)** language. 
OOP is a methodology for structuring programs by using objects.

An object bundles together functions (methods) and the data required for those functions to work. 
This helps make it easier to build larger, more complex programs.

An object bundles behaviors (what it can do) and the data needed to perform those behaviors. 
More specifically, it includes the functions that define the behaviors and the variables that hold the data.

Objects are said to be encapsulated, meaning they wrap up their data and behaviors. 
This allows the programmer to use the object without needing to worry about all of its internal details.
{% include end-box.html %}

# 1. OOP (Object-Oriented Programming)
{% include start-box.html class="math-box"%}
We have already used various kinds of objects. 
For example, let's think about the `str` (string) object.

- `a` and `b` (or more precisely, the objects associated with the names `a` and `b`) hold the data "hello" and "abc".
- "hello" and "abc" have different values but are the same type, so they can be used in the same way. This shows that well-designed data types are easy to reuse.
- `a` and `b` can also perform actions using methods. For example, both `a` and `b` can use the `.upper()` method to change their data.
- When you want to perform an action, you can simply use `.upper()` to "make this uppercase" without caring what specific data is inside `a` or `b`.

```python
a = str("hello")
b = str("abc")

print(type(a), type(b))  # <class 'str'> <class 'str'>

a.upper(), b.upper() # 'HELLO', 'ABC'
```
```python
<class 'str'> <class 'str'>

('HELLO', 'ABC')
```

Here are some advantages of OOP:

- You don't need to know the internal details.
- It's easy to reuse well-designed data types.
- You can design the program's structure from an abstract perspective.

Let's summarize the important terms.

- **Object** : In Python, everything is an object. More specifically, it refers to a bundle of data and functionality.
- **Class** : A template that defines what data an object will have and what functions it can perform. In other words, it defines a data type. 
- **Instance** : Since everything in Python is an object, the concept of an object is very important. When you want to emphasize that an object was created according to a specific class, you call that object an instance of that class. : For example, in `a = str("hello")`, `a` is an instance of the `str` class. : "Object" and "instance" are often used interchangeably.
- **Attribute** : The components that make up a class are called attributes. In Python, anything that can be used by placing a dot (`.`) after a variable is called an attribute.
- **Data Attribute** : Refers to the variables that are part of an object (or class).
- **Method** : Refers to the functions that belong to an object (or class).

    Ex) Think of a TV Class<br>
    Data Attributes: Size, Color, Current Channel<br>
    Methods: Turn on/off, Change Channel, Volume Control

To check which class an object is an instance of, you can use the `isinstance()` function.
```python
a = str("hello")
b = str("abc")

# Use isinstance() to check what type of instance an object is.
isinstance(a, str), isinstance(b, str) # (True, True)
```
```python
(True, True)
```
{% include end-box.html %}

# 2. Creating a Data Type with `Class`
{% include start-box.html class="math-box"%}

## 2-1) Creating a Data Type with `Class`
You can create and use your own necessary data types by using the `class` syntax.

[Definition of a Class]
- Class Name
- Methods
- Data Attributes

```
class MyInt:                   
    def __init__(self, value):   
        self.v = value         
                               
    def add(self, a):
        self.v = self.v + a
```

<figure style="display: flex; flex-direction: column; align-items: center; margin-top: 0.5em; margin-bottom: 0.5em;">
  <img src="../images/2025-11-17-Python_15/Fig_1.png" alt="" 
       style="width: 110%; height: auto;">
</figure> 

```python
# Defined using the class keyword
# Use CamelCase for class names
class MyInt:
    # A special method executed automatically when an instance is created
    # Note the two underscores before and after init
    # magic or Dunder (Double UNDERscores) methods
    # Called a constructor in C++ or Java.
    # self is a reference (variable) to the instance
    def __init__(self, value):
        # Define instance variable
        self.value = value

    # Define method (the first parameter is self)
    def add(self, a):
        self.value = self.value + a

    # Define method (the first parameter is self)
    def print(self):
        print(self.value)

# You can create multiple instances.
my_int1 = MyInt(123) # __init__(123)
my_int2 = MyInt(456) # __init__(456)

print(my_int1.value) # 123
my_int1.add(1) # No need to pass self when calling the method.
my_int1.print() # 124

print(my_int2.value) # 456
my_int2.add(1)
my_int2.print() # 457
```
```python
123
124
456
457
```

## 2-2) ID of `self` and Instance
{% include start-box.html class="math-box"%}
The `id` of an object (instance) created from a class is identical to the `id` of `self` when that object (instance) is created. 
Even if you continue to apply the class's methods to it, the `id` remains unchanged.

Furthermore, the object of a class and its instance variables have different IDs. 
In other words, when a new class object is created, the corresponding instance variables for that object are also newly created.

```python
class MyInt:
    def __init__(self, value):
        self.value = value
        # Check the ID of 'self' when initialized
        print(id(self))
        
    def add(self, a):
        self.value = self.value + a
        # Check the ID of 'self' inside a method
        print(id(self))
        
    def print(self):
        print(self.value)
        print(id(self))

# 1. Create two instances
a = MyInt(1)
b = MyInt(2)

# 2. Check values and IDs
print(a.value, b.value)
print(id(a.value), id(b.value))
```
```python
1759240711392
1759240708416
1 2
1759189598448 1759189598480
```

```python
class MyInt:
    def __init__(self, value):
        self.value = value
        print(id(self)) # (Optional: print ID on init)

    def add(self, a):
        self.value = self.value + a
        print(id(self)) # (Optional: print ID on add)

    def print(self):
        print(self.value)
        print(id(self)) # (Optional: print ID on print)

print("id of self of my_int1 before add method")
my_int1 = MyInt(123)
print(id(my_int1)) # Matches the ID of 'self'

print("\nid of my_int1(instance)")
print(id(my_int1))

print("\nid of self.value of my_int1(instance)")
print(id(my_int1.value))

print("\nid of self of my_int2 before add method")
my_int2 = MyInt(1234)
print(id(my_int2))

print("\nid of self.value of my_int2(instance)")
print(id(my_int2.value))

print("\nid of self after add method")
my_int1.add(1)
print(id(my_int1)) # ID remains the same

print("\nid of self after print method")
my_int1.print() # 124
print(id(my_int1)) # ID remains the same

print("\nid of my_int1 after methods")
print(id(my_int1)) # ID remains the same

# Note: The ID of the VALUE (an integer) changes because integers are immutable.
# But the ID of the instance 'my_int1' stays constant.
print()
print(id(my_int1.value))
```
```python
id of self of my_int1 before add method
1528504686992
1528504686992

id of my_int1(instance)
1528504686992

id of self.value of my_int1(instance)
1528427188272

id of self of my_int2 before add method
1528504689728
1528504689728

id of self.value of my_int2(instance)
1528504266032

id of self after add method
1528504686992
1528504686992

id of self after print method
124
1528504686992
1528504686992

id of my_int1 after methods
1528504686992

1528427188304
```
{% include end-box.html %}
{% include end-box.html %}

# 3. Namespace
{% include start-box.html class="math-box"%}

## 3-1) Namespace and `__main__`

When you print the type of an instance created from a class, you often see `__main__` attached to the front. What does this mean?

```python
class MyClass:
    pass # Minimal class definition

# Create an instance of the class
i = MyClass()

print(type(i))
```
```python
<class '__main__.MyClass'>
```

Namespace refers to the space where variables, functions, classes, and other names are stored.
You can use the built-in function `dir()` to check what names are in a specific scope or object. `dir` stands for directory. Let's use it to see what names are in the global scope.

```python
# Run dir() in the Global scope
dir()
```
```python
['In',
 'MyClass',
 'MyInt',
 'Out',
 '_',
 '_1',
 '_2',
 '__',
 '___',
 '__builtin__',
 '__builtins__',
 '__doc__',
 '__loader__',
 '__name__',
 '__package__',
 '__spec__',
 '__vsc_ipynb_file__',
 '_dh',
 '_i',
 '_i1',
 '_i10',
 '_i2',
 '_i3',
 '_i4',
 '_i5',
 '_i6',
 '_i7',
 '_i8',
 '_i9',
 '_ih',
 '_ii',
 '_iii',
 '_oh',
 'a',
 'b',
 'exit',
 'get_ipython',
 'i',
 'my_int1',
 'my_int2',
 'open',
 'quit']
```

When you check the names in the global scope with `dir()`, you can see that `__name__` is present. If you print it, you will see the output `__main__`.

```python
print(__name__)
```
```python
__main__
```

`__name__` tells you the name of the module. 
When `__name__` is `__main__`, it means the script is being run directly by the user, rather than being imported as part of another module.

```python
import numpy as np

print("np.__name__:", np.__name__) # numpy -> original module name

import json

print("json.__name__:", json.__name__) # json

print("__name__:", __name__) # __main__
```
```python
np.__name__: numpy
json.__name__: json
__name__: __main__
```

When you execute a program or script, you are asking the operating system to run it. 
The OS then looks for the entry point of the program or script and starts execution from there. 
The OS needs a starting point to begin the program. 
In other languages, this is usually a function or method named main. 
In those languages, the programmer must write this starting point directly. 
However, Python handles this internally, so there's no need for an explicit main function.

If the current `__name__` namespace is `__main__` (meaning the script was executed directly by the user and not imported as part of a module), you can use the following pattern to intentionally execute a `main()` function:

```python
# Usually used in script mode.

def main():
    # Things you want to do
    print("I am", __name__)

if __name__ == "__main__":
    main()
```
```python
I am __main__
```

## 3-2) Objects and Namespace
In Python, an object itself is also a namespace.

If you create an instance `i` of a class named `MyClass` and inspect its namespace using `dir(i)`, you can see the instance variables and methods defined within the `MyClass` class.
```python
class MyClass:
    
    def __init__(self):
        self.my_variable = "Hello"
        
    def my_method(self):
        pass

# Create an instance
i = MyClass()

print(i.my_variable)
i.my_method()

# Check the namespace of the instance 'i'
dir(i)
```
```python
Hello
['__class__',
 '__delattr__',
 '__dict__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__init_subclass__',
 '__le__',
 '__lt__',
 '__module__',
 '__ne__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 '__weakref__',
 'my_method',
 'my_variable']
```

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Adding Attributes Dynamically**<br>
You can also add new attribute names (variables or methods) to an instance after it has been created. However, even though the syntax allows it, this is generally **not recommended** as good practice.
```python
class EmptyClass:
    pass

    # def __init__(self):
    #     self.my_variable = "Hello"
    
    # def any_method(self):
    #     self.my_variable = "Hello"

e = EmptyClass()

# Adding an instance variable dynamically
e.my_variable = "Hello"
# Compare this to: defining self.my_variable = "Hello" inside a method

# Adding a method dynamically using a lambda
e.my_method = lambda : print("Hi")

# e.my_method()

# Check the namespace
dir(e)
```
```python
['__class__',
 '__delattr__',
 '__dict__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__init_subclass__',
 '__le__',
 '__lt__',
 '__module__',
 '__ne__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 '__weakref__',
 'my_method',
 'my_variable']
```
{% include end-box.html %}
{% include end-box.html %}

# 4. Class Variables
{% include start-box.html class="math-box"%}
## 4-1) What is a Class Variable?
A variable that belongs to the class itself, rather than to any individual instance, is called a class variable.
While multiple instances can be created from a class, only one copy of a class variable is created and shared among them all.

Class variables are accessed using the class name.
- Syntax: `(ClassName).(ClassVariableName)`

You can access a class variable through `self` if there is no instance variable with the same name.
However, if you accidentally assign a value like `self.class_var = "1234"`, you are not changing the class variable. Instead, you are creating a new instance variable with that name. Therefore, it is not recommended to access class variables via `self`.

{% include start-box.html class="math-box"%}
As shown in the output, while the instance variables (on the right) are different for each object, the class variable (on the left) is the same for all objects. 
Furthermore, as seen at the bottom of the code, changing the class variable affects every instance.
```python
class MyClass:  
    # Define a class variable
    class_var = "Class variable"
    
    def __init__(self, value):
        self.inst_var = value
        
    # Class variables are accessed via the Class Name.
    def print(self):
        print(MyClass.class_var, self.inst_var)

print(MyClass.class_var) # Accessing via Class Name

i1 = MyClass(123)
i2 = MyClass(456)
i3 = MyClass(789)

i1.print() # Class variable 123
i2.print() # Class variable 456
i3.print() # Class variable 789

# Changing the class variable affects ALL instances
MyClass.class_var = "Changed"

i1.print() # Changed 123
i2.print() # Changed 456
i3.print() # Changed 789
```
```python
Class variable
Class variable 123
Class variable 456
Class variable 789
Changed 123
Changed 456
Changed 789
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
You can use a class variable to count the total number of instances created.
```python
class Person:
    num_people = 0  # Class variable to track count
    
    def __init__(self, name):
        self.name = name
        # Increment the class variable every time a new instance is created
        Person.num_people += 1 
        print(f"{self.name} created. Current count: {Person.num_people}")

p1 = Person("First person")
p2 = Person("Second person")
p3 = Person("Third person")
```
```python
First person created. Current count: 1
Second person created. Current count: 2
Third person created. Current count: 3
```
{% include end-box.html %}

## 4-2) Decorators
- `@`: This symbol is read as the "at sign".
- **Decorator**: When `@` is placed above a function definition (e.g., `@classmethod`), it is called a decorator because it "decorates" the function.
- Decorators add functionality to the function they are attached to.

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Class Method**<br>
`@classmethod`: This decorator is used to define a class method.
```python
class MyClass:
    
    class_var = "Class variable"
    
    def __init__(self, value):
        self.inst_var = value
        
    def print(self):
        print(MyClass.class_var, self.inst_var)
        
    @classmethod
    def change_class_var(cls, new_value):
        cls.class_var = new_value
        # Note: It's hard to access instance variables (e.g., self.inst_var) here
        # because there is no 'self' parameter.

i1 = MyClass(123)
i2 = MyClass(456)

# Using a class method from an instance
i2.change_class_var("Changed")

i1.print()
i2.print()

# Using a class method from the class name
MyClass.change_class_var("Changed again")

i1.print()
i2.print()
```
```python
Changed 123
Changed 456
Changed again 123
Changed again 456
```
**Key Characteristics of Class Methods:**
1. Unlike regular methods, the first parameter is `cls`, not `self`.
2. You can use `cls` to access class variables (e.g., `cls.class_var`).
3. Because there is no `self`, you cannot easily access instance variables. (Class methods are designed to work with class-level data, not instance-specific data).
4. You can call a class method using either an instance name (e.g., `i2.change_class_var(...)`) or the class name (e.g., `MyClass.change_class_var(...)`). In both cases, Python automatically passes the class as the `cls` argument.
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Static Method**<br>
- `@staticmethod`: This decorator is used to define a **static method**.
- Static methods are used when you want to place a method inside a class that doesn't depend on the class or its instances.
```python
class MyClass:
    class_var = "class var"
    
    def __init__(self, value):
        self.inst_var = value
        
    # Python does NOT automatically pass 'self' or 'cls' to static methods.
    @staticmethod
    def static_print():
        print("Hello, World!")
        
        # You CAN access class variables using the Class Name,
        # but if you need to do this, a Class Method is usually better.
        print(MyClass.class_var)
        
        # If you need to modify class variables,
        # it is recommended to use a Class Method instead.

i1 = MyClass(123)
i2 = MyClass(456)

MyClass.static_print()

i1.static_print()
i2.static_print()
```
```python
Hello, World!
class var
Hello, World!
class var
Hello, World!
class var
```
**Key Characteristics of Static Methods:**
1. They do not take `self` or `cls` as implicit first arguments.
2. While you can access class variables explicitly using the class name, if you need to interact with class data, it's generally better to use a `@classmethod`.
3. They are essentially regular functions that just happen to live inside a class's namespace for organizational purposes.
{% include end-box.html %}
{% include end-box.html %}

# 5. Operator Overloading
{% include start-box.html class="math-box"%}
Just as the `__init__()` method has a predefined role (initializing an object), there are other methods with specific names that correspond to specific behaviors.
To allow our custom classes to use standard operators (like `+`, `-`, `==`) just like built-in data types do, we need to define methods with special names.
This process of giving special meaning to an operator for a user-defined class is called Operator Overloading.

For example, the int data type works seamlessly with operators:
```python
x = int(1)
y = int(3)

a = x + y # Internally calls x.__add__(y)
print(a)  # Output: 4
```
```python
4
```
<br>
Let's try to use the + operator with a custom `Vector2D` class.
```python
class Vector2D:
    # Take two numbers as parameters and assign them to instance variables
    def __init__(self, x, y):
        self.x = x
        self.y = y

v1 = Vector2D(1, 2)
v2 = Vector2D(3, 4)

# Trying to add two Vector2D objects directly will cause an error
# v3 = v1 + v2
```
```python
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Cell In[6], line 10
      7 v1 = Vector2D(1, 2)
      8 v2 = Vector2D(3, 4)
---> 10 v3 = v1 + v2 # ???

TypeError: unsupported operand type(s) for +: 'Vector2D' and 'Vector2D'
```
This error occurs because Python doesn't know how to "add" two `Vector2D` objects. When you use the `+` operator, Python internally looks for and calls the `__add__()` method. Since we haven't defined this method in our class, the operation fails.

To fix this, we can define the `__add__` method to specify what "addition" means for a 2D vector.

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Overloading `+` (`__add__`)**<br>
Let's try to use the `+` operator with a custom `Vector2D` class.
```python
class Vector2D:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    # Define how the + operator should work
    def __add__(self, v):
        # Returns a NEW Vector2D object whose x and y are the sums of the operands
        return Vector2D(self.x + v.x, self.y + v.y)

v1 = Vector2D(1, 2)
v2 = Vector2D(3, 4)

v3 = v1 + v2 # Now calls v1.__add__(v2)

print(v3.x, v3.y)
print(v3) # ???
```
```python
4 6
<__main__.Vector2D object at 0x0000022516C344C0>
```
When we use `+`, Python calls `__add__`. The object on the left (`v1`) is `self`, and the object on the right (`v2`) is passed as the argument `v`.
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Overloading `print()` (`__str__`)**<br>
In the output above, `print(v3)` displayed the memory address `<__main__.Vector2D object ...>` instead of the vector's values. This is the default behavior when a class doesn't have a `__str__()` method.

To control what is printed when we pass an object to `print()`, we need to define the `__str__` method. This method must return the string that we want to display.
```python
class Vector2D:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, v):
        return Vector2D(self.x + v.x, self.y + v.y)
    
    # Define the string representation for print()
    def __str__(self):
        return f"({self.x}, {self.y})"

v1 = Vector2D(1, 2)
v2 = Vector2D(3, 4)
v3 = v1 + v2

print(v3) # Now it calls v3.__str__()
```
```python
(4, 6)
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Overloading == (__eq__)**<br>
To allow comparing two objects using the `==` operator, we need to define the `__eq__()` method (short for "equal"). This method should return a boolean (`True` or `False`).

**Example 1: Concise Implementation**
```python
class Vector2D:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        
    def __eq__(self, v):
        # Returns True if both x and y components are equal
        return self.x == v.x and self.y == v.y

v1 = Vector2D(1, 2)
v2 = Vector2D(3, 4)

print(v1 == v2)               # False
print(v1 == Vector2D(1, 2))   # True
```
```python
False
True
```
<br>
**Example 2: Verbose Implementation (Logic is the same)**
```python
class Vector2D:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __eq__(self, v1, v2): # Note: Usually defined as __eq__(self, other)
        if v1.x - v2.x:       # If difference is non-zero (True)
            return False
        else:
            if v1.y - v2.y:   # If difference is non-zero (True)
                return False
            else:
                return True

v1 = Vector2D(1, 2)
v2 = Vector2D(3, 4)

print(v1 == v2)
print(v1 == Vector2D(1, 2))
```
```python
False
True
```
{% include end-box.html %}
{% include end-box.html %}

# 6. Inheritance
{% include start-box.html class="math-box"%}

{% include end-box.html %}













```python

```
```python

```



<div class="indented-paragraph" markdown="1">

</div>

{% include start-box.html class="math-box-inner" font_size="0.8em"%}

```python

```
```python

```
{% include end-box.html %}


{% include start-box.html class="math-box"%}

{% include end-box.html %}