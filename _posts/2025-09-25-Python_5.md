---
layout: single
title:  "5.List"
category: "Python"
tag: [Python]
header:
  teaser: #../images/2025-07-08-CT_6/image-20250708184503610.png
toc: true
toc_sticky: true
toc_label: CONTENTS
toc_icon: "fa-solid fa-seedling" # More icons: https://fontawesome.com/v6/search?ic=free
author_profile: false
sidebar:
    nav: "counts"
search: true # Change true to false if you don't want to have this article be searched 
redirect_from:
    - /Python/Python_5
use_math: true
---

**[Reference]** <br>
$\bullet$ [홍정모의 파이썬 프로그래밍 추월코스](https://www.honglab.ai/courses/python)<br>
This post is written based on above lecture.<br>
All contents in this post are not the same with above lecture.<br>
Please show the detail at the his lecture.
{: .notice--success}

# 0. Introduction
{% include start-box.html class="math-box"%}
The list is the most flexible and commonly used container in Python.<br>
Lists have the following properties: 
- mutable
- ordered 
- allow duplicate elements.
{% include end-box.html %}

# 1. List
{% include start-box.html class="math-box"%}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
A list is created with `[]`, and its **_items_** are separated by commas `,`.
```python
my_list = []         # An empty list
my_list = [1, 2, 3]  # A list of items
my_list = ["A string", 23, 100.232, "o"]  # Can hold objects of different data types
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
We count number of list using `len()`.
```python
my_list = [1, 2, 3]

len(my_list)
```
```python
3
```
{% include end-box.html %}
{% include end-box.html %}




# 2. List indexing and slicing
{% include start-box.html class="math-box"%}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
List indexing
```python
my_list = ["One", 2, "Third", 4.0]

my_list[2]
```
```python
'Third'
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
List slicing<br>
The slicing rules are the same as they are for `str`.
```python
my_list = ["One", 2, "Third", 4.0]

my_list[2:]
```
```python
['Third', 4.0]
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
Because lists are a mutable data type, it is possible to assign items to them using slicing.
```python
my_list = [0, 1, 2, 3, 4, 5]
print(id(my_list), my_list)

my_list[1:3] = ["A", "B", "C"]
print(id(my_list), my_list)
```
```python
2313572468096 [0, 1, 2, 3, 4, 5]
2313572468096 [0, 'A', 'B', 'C', 3, 4, 5]
```
We can see that the `id` of the list remains the same, even though its items have changed.
{% include end-box.html %}
{% include end-box.html %}



# 3. Mutability of List
{% include start-box.html class="math-box"%}
Unlike `str`, `lists` are a mutable data type. 
Because they are mutable, their contents can be changed without altering their `id`.
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
```python
my_list = ["Before"]
print(id(my_list), my_list)

my_list[0] = "After"
print(id(my_list), my_list)
```
```python
2313572382144 ['Before']
2313572382144 ['After']
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
Add items with the `+` operator (This operation only works between lists)
```python
my_list = ["item"]
print(my_list + ["added item"])

print(my_list)
```
```python
['item', 'added item']
['item']
```
The original list is not changed.
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
When we add items to a list using the '+' operator, a new object with a new `id` is created.
Even with a mutable object, we can still create a new one.
```python
my_list = ["item"]
print(id(my_list), my_list)

my_list = my_list + ["added item"]
print(id(my_list), my_list)
```
```python
2313572476032 ['item']
2313571755712 ['item', 'added item']
```
{% include end-box.html %}

{% include end-box.html %}




# 4. List and operator
{% include start-box.html class="math-box"%}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
When we reassign a list using operators like `+` or `*`, the `id` changes. 
However, when we use augmented assignment operators like `+=` or `*=`, the `id` does not change.
```python
my_list = ["item"]
print(id(my_list), my_list)

my_list += ["added item"]
print(id(my_list), my_list)
```
```python
2313572379392 ['item']
2313572379392 ['item', 'added item']
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
List multiplication
```python
my_list = ["item"]
print(id(my_list), my_list)

my_list *= 2
print(id(my_list), my_list)

my_list = my_list*2
print(id(my_list), my_list)
```
```python
2313593502720 ['item']
2313593502720 ['item', 'item']
2313572379392 ['item', 'item', 'item', 'item']
```
`*=` dose not change the `id`, but `=` and `*` change the `id`.
{% include end-box.html %}
{% include end-box.html %}



# 5. List and Method
{% include start-box.html class="math-box"%}
To modify a string, we have to create a new object. 
However, because `lists` are a mutable data type, we can change their contents while keeping the original object.
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`list.append()`<br>
We can use the `list.append()` method to add an item to a `list` without changing the `list`'s `id`.
```python
my_list = ["item"]
print(id(my_list), my_list)

my_list.append("added item")
print(id(my_list), my_list)
```
```python
2313572398208 ['item']
2313572398208 ['item', 'added item']
```
<br>
The `list.append()` method returns `None` because it modifies the existing object in-place instead of creating a new one.
```python
my_list = ["item"]
print(id(my_list), my_list)

new_list = my_list.append("added item")
print(id(new_list), new_list, type(new_list))
```
```python
2313572366080 ['item']
140732728438464 None <class 'NoneType'>
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`list.pop()`<br>
The `list.pop()` method removes and returns an item from a specified position.
```python
my_list = ["item 1", "item 2", "item 3"]
print(id(my_list), my_list)

pop_item = my_list.pop(1)
print(id(pop_item), pop_item, type(pop_item))

print(id(my_list), my_list)
```
```python
2313593547904 ['item 1', 'item 2', 'item 3']
2313593500080 item 2 <class 'str'>
2313593547904 ['item 1', 'item 3']
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`list.reverse()`<br>
We can use the `list.reverse()` method to reverse the order of a `list` without changing its `id`.
```python
my_list = ["item 1", "item 2", "item 3"]
print(id(my_list), my_list)

my_list.reverse()
print(id(my_list), my_list)
```
```python
2313593639168 ['item 1', 'item 2', 'item 3']
2313593639168 ['item 3', 'item 2', 'item 1']
```
<br>
Like other in-place methods, the `list.reverse()` method returns None because it modifies the existing object directly instead of creating a new one.
```python
my_list = ["item 1", "item 2", "item 3"]
print(id(my_list), my_list)

reverse_list = my_list.reverse()
print(id(reverse_list), reverse_list, type(reverse_list))
```
```python
2313593545984 ['item 1', 'item 2', 'item 3']
140732728438464 None <class 'NoneType'>
```
<br>
To create a new, reversed list, we can use reverse slicing with [::-1].
```python
my_list = ["item 1", "item 2", "item 3"]
print(id(my_list), my_list)

reverse_list = my_list[::-1]
print(id(reverse_list), reverse_list, type(reverse_list))
```
```python
2313593544640 ['item 1', 'item 2', 'item 3']
2313572366080 ['item 3', 'item 2', 'item 1'] <class 'list'>
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`list.sort()`<br>
The `list.sort()` method only works when all the items in a list are comparable with each other. 
For example, since numbers and strings cannot be compared, attempting to sort a list that contains a mix of these types will raise a `TypeError`.
When all items in a `list` are of the same or a comparable type, `list.sort()` arranges them in ascending order by default.
```python
my_list = [5, 10, 1, 7]
print(id(my_list), my_list)

my_list.sort()
print(id(my_list), my_list)
```
```python
2313572170240 [5, 10, 1, 7]
2313572170240 [1, 5, 7, 10]
```
<br>
```python
my_list = ["item 3", "item 1", "item 2"]
print(id(my_list), my_list)

my_list.sort()
print(id(my_list), my_list)
```
```python
2313593891904 ['item 3', 'item 1', 'item 2']
2313593891904 ['item 1', 'item 2', 'item 3']
```
<br>
We can sort a list in descending order by passing the argument `reverse=True` to the `list.sort()` method.
```python
my_list = ["item 3", "item 1", "item 2"]
print(id(my_list), my_list)

my_list.sort(reverse = True)
print(id(my_list), my_list)
```
```python
2313593880192 ['item 3', 'item 1', 'item 2']
2313593880192 ['item 3', 'item 2', 'item 1']
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`list.clear()`<br>
```python
my_list = ["item 1", "item 2", "item 3"]
print(id(my_list), my_list)

my_list.clear()
print(id(my_list), my_list)
```
```python
2313593488576 ['item 1', 'item 2', 'item 3']
2313593488576 []
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`list.count()`<br>
Count number of items in list.
```python
my_list = ["one", "two", "two", "three", "three", "three"]

my_list.count("three")
```
```python
3
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`list.extend()`<br>
The `list.extend()` method appends all the items from another list to the end of the current list.
```python
my_list = ["one", "two", "two", "three", "three", "three"]
print(id(my_list), my_list)

add_list = ["four", "four", "four", "four"]

my_list.extend(add_list)
print(id(my_list), my_list)
```
```python
2313593877632 ['one', 'two', 'two', 'three', 'three', 'three']
2313593877632 ['one', 'two', 'two', 'three', 'three', 'three', 'four', 'four', 'four', 'four']
```
<br>
Unlike `list.append()`, the `list.extend()` method unpacks an iterable and adds its individual elements, whereas `list.append()` adds the entire iterable as a single element.
```python
my_list = ["one", "two", "two", "three", "three", "three"]
print(id(my_list), my_list)

add_list = ["four", "four", "four", "four"]

my_list.append(add_list)
print(id(my_list), my_list)

# ----------------------------------------------------------

my_list = ["one", "two", "two", "three", "three", "three"]
print(id(my_list), my_list)

my_list.extend(add_list)
print(id(my_list), my_list)
```
```python
2313571589248 ['one', 'two', 'two', 'three', 'three', 'three']
2313571589248 ['one', 'two', 'two', 'three', 'three', 'three', ['four', 'four', 'four', 'four']]
2313572170688 ['one', 'two', 'two', 'three', 'three', 'three']
2313572170688 ['one', 'two', 'two', 'three', 'three', 'three', 'four', 'four', 'four', 'four']
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`list.index()`<br>
The `list.index()` method returns the index of the first occurrence of a given item in a list.
```python
my_list = ["one", "two", "two", "three", "three", "three"]
my_list.index("three")
```
```python
3
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`list.remove()`<br>
The `list.remove()` method removes the first matching value from a `list`.
```python
my_list = ["one", "two", "two", "three", "three", "three"]
print(id(my_list), my_list)

my_list.remove("three")
print(id(my_list), my_list)
```
```python
2313572357568 ['one', 'two', 'two', 'three', 'three', 'three']
2313572357568 ['one', 'two', 'two', 'three', 'three']
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`list.insert()`<br>
The `list.insert()` method takes an index and an item as arguments, then inserts the item into the `list` at the specified index.
```python
my_list = ["one", "two", "four"]
print(id(my_list), my_list)

my_list.insert(2, "three")
print(id(my_list), my_list)
```
```python
2313593424512 ['one', 'two', 'four']
2313593424512 ['one', 'two', 'three', 'four']
```
{% include end-box.html %}
{% include end-box.html %}

# 6. Nested List
{% include start-box.html class="math-box"%}
A list that contains another list as an item is called a **_nested list_**.
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
Nested list
```python
my_list = [["White", "Blue", "Red"], "Mandarin", "Apple", "Banana", [1, 2, 3]]
my_list
```
```python
[['White', 'Blue', 'Red'], 'Mandarin', 'Apple', 'Banana', [1, 2, 3]]
```
<br>
```python
colors = ["White", "Blue", "Red"]
fruits = ["Mandarin", "Apple", "Banana"]

result = [colors, fruits]

print(result)
print(result[0][1])
```
```python
[['White', 'Blue', 'Red'], ['Mandarin', 'Apple', 'Banana']]
Blue
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
Indexing of nested list
```python
my_list = [["White", "Blue", "Red"], "Mandarin", "Apple", "Banana", [1, 2, 3]]

print(my_list[0], type(my_list[0]))
```
```python
['White', 'Blue', 'Red'] <class 'list'>
```
<br>
```python
my_list = [["White", "Blue", "Red"], "Mandarin", "Apple", "Banana", [1, 2, 3]]

print(my_list[0:2])
```
```python
[['White', 'Blue', 'Red'], 'Mandarin']
```
<br>
If the result of indexing a list is another list, we can index it again.
```python
my_list = [["White", "Blue", "Red"], "Mandarin", "Apple", "Banana", [1, 2, 3]]

print(my_list[0][1])
```
```python
Blue
```
{% include end-box.html %}
{% include end-box.html %}

# 7. Mutable and Immutable Objects Within a List
{% include start-box.html class="math-box"%}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
Duplication of list
```python
my_list = [["White", "Blue", "Red"], "Mandarin", "Apple", "Banana", [1, 2, 3]]

my_list_copy = my_list.copy()

print(id(my_list), id(my_list_copy))

```
```python
2313593517824 2313594051072
```
When we copy a `list` using the `list.copy()` method, the new list is a separate object with a different address (`id`) from the original.
<br>
```python
my_list = [["White", "Blue", "Red"], "Mandarin", "Apple", "Banana", [1, 2, 3]]

my_list_copy = my_list.copy()

print(id(my_list), id(my_list_copy))
print(id(my_list[0]), id(my_list_copy[0]))
print(id(my_list[0][1]), id(my_list_copy[0][1]))
```
```python
2313594041088 2313593505152
2313572667264 2313572667264
2313542698160 2313542698160
```
However, address of items are same.
It means that `list.copy()` creates a new "container", but fills it with references to the same items that were in the original list.
<div class="indented-paragraph" markdown="1">
**_Shallow copy_**
</div>
<br>
Since the `list.copy()` method performs a shallow copy, a key distinction arises when we copy a list containing mutable objects and then modify one of those nested objects.
```python
my_list = [["White", "Blue", "Red"], "Mandarin", "Apple", "Banana", [1, 2, 3]]

my_list_copy = my_list.copy()

my_list_copy[0] = "Black"

print(my_list, my_list_copy)
print(f'{"Address of list:":>{36}}', id(my_list), id(my_list_copy))
print(f'{"Address of first item:":>{36}}', id(my_list[0]), id(my_list_copy[0]))
print(f'{"Address of scond item in first item:":>{36}}', id(my_list[0][1]), id(my_list_copy[0][1]))
```
```python
[['White', 'Blue', 'Red'], 'Mandarin', 'Apple', 'Banana', [1, 2, 3]] ['Black', 'Mandarin', 'Apple', 'Banana', [1, 2, 3]]
                    Address of list: 2313572398592 2313572676224
              Address of first item: 2313593975680 2313542713200
Address of scond item in first item: 2313542698160 2313495522416
```

<br>
```python
my_list = [["White", "Blue", "Red"], "Mandarin", "Apple", "Banana", [1, 2, 3]]

my_list_copy = my_list.copy()

my_list_copy[0][0] = "Black"

print(my_list, my_list_copy)
print(f'{"Address of list:":>{36}}', id(my_list), id(my_list_copy))
print(f'{"Address of first item:":>{36}}', id(my_list[0]), id(my_list_copy[0]))
print(f'{"Address of scond item in first item:":>{36}}', id(my_list[0][1]), id(my_list_copy[0][1]))
```
```python
[['Black', 'Blue', 'Red'], 'Mandarin', 'Apple', 'Banana', [1, 2, 3]] [['Black', 'Blue', 'Red'], 'Mandarin', 'Apple', 'Banana', [1, 2, 3]]
                    Address of list: 2313593635136 2313594003840
              Address of first item: 2313593494720 2313593494720
Address of scond item in first item: 2313542698160 2313542698160
```
The reason this happens is that the items in a `list` are not the objects themselves, but rather references (or "name tags") to the objects.
{% include end-box.html %}
{% include end-box.html %}

# 8. List comprehensions
{% include start-box.html class="math-box"%}
Instead of listing items one by one, list comprehensions allow you to create a `list` by describing the conditions for its items. 
The basic syntax involves writing an expression inside `[]`, followed by a for clause. 
It looks like a condensed `for` loop placed within the brackets.
<div class="indented-paragraph" markdown="1">
[_expression_ **for** _item_ **in** _iterable_]
</div>

## 8-1) List comprehension
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
```python
my_list = [x**2 for x in range(1,11)]

print(my_list)
```
```python
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```
<br>
We can use list comprehension for iterable.
```python
my_list = [x**2 for x in [x for x in range(11)]]

print(my_list)
```
```python
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```
{% include end-box.html %}

## 8-2) List comprehension and for loop
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
We can use list comprehension with multiple iterable.
```python
# for loop
my_list_for = []

for num in [1,2,3]:
    for fruit in ["Apple", "Banana", "Mandarin"]:
        my_list_for.append((num, fruit))

print(my_list_for)

# List comprehension
my_list_com = [(num, fruit) for num in [1,2,3] for fruit in ["Apple", "Banana", "Mandarin"]]
print(my_list_com)

# type of list and item
print(type(my_list_for), type(my_list_for))
print(type(my_list_for[0]), type(my_list_for[0]))
```
```python
[(1, 'Apple'), (1, 'Banana'), (1, 'Mandarin'), (2, 'Apple'), (2, 'Banana'), (2, 'Mandarin'), (3, 'Apple'), (3, 'Banana'), (3, 'Mandarin')]
[(1, 'Apple'), (1, 'Banana'), (1, 'Mandarin'), (2, 'Apple'), (2, 'Banana'), (2, 'Mandarin'), (3, 'Apple'), (3, 'Banana'), (3, 'Mandarin')]
<class 'list'> <class 'list'>
<class 'tuple'> <class 'tuple'>
```
`()` are required when we want to include a tuple as an item in a list.
{% include end-box.html %}

## 8-3) List comprehension and conditional statements
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
```python
my_list = [x**2 for x in range(11) if x % 2 == 0]

print(my_list)
```
```python
[0, 4, 16, 36, 64, 100]
```
<br>
```python
[(x, y) for x in range(1, 7) if x>2 for y in range(1,7) if x + y == 10]
```
```python
[(4, 6), (5, 5), (6, 4)]
```
{% include end-box.html %}

## 8-4) List comprehension and method
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
We can use list comprehension with method.
```python
neg_list = [-3, -2, -1]

pos_list = [abs(x) for x in neg_list]

pos_list
```
```python
[3, 2, 1]
```
<br>
```python
neg_list = [-3, -2, -1]

pos_list = [abs(x) for x in neg_list if abs(x)>1]

pos_list
```
```python
[3, 2]
```
<br>
```python
small_list = ["apple", "banana", "mandarin"]

big_list = [x.upper() for x in small_list]

big_list
```
```python
['APPLE', 'BANANA', 'MANDARIN']
```
{% include end-box.html %}

## 8-5) Unpack of list item
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
We can use list comprehension to unpack the `list` used for item of `list`.
```python
nested_list = [["White", "Blue", "Red"], ["Mandarin", "Apple", "Banana"], [1, 2, 3]]

[val for sub_list in nested_list for val in sub_list]
```
```python
['White', 'Blue', 'Red', 'Mandarin', 'Apple', 'Banana', 1, 2, 3]
```
{% include end-box.html %}
{% include end-box.html %}