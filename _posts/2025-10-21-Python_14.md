---
layout: single
title:  "14.Numpy"
category: "Python"
tag: [Python]
header:
  teaser: #../images/2025-07-08-CT_6/image-20250708184503610.png
toc: true
toc_sticky: true
toc_label: CONTENTS
toc_icon: "fa-solid fa-seedling" # More icons: https://fontawesome.com/v6/search?ic=free
author_profile: false
sidebar:
    nav: "counts"
search: true # Change true to false if you don't want to have this article be searched 
redirect_from:
    - /Python/Python_14
use_math: true
---

**[Reference]** <br>
$\bullet$ [홍정모의 파이썬 프로그래밍 추월코스](https://www.honglab.ai/courses/python)<br>
This post is written based on above lecture.<br>
All contents in this post are not the same with above lecture.<br>
Please show the detail at the his lecture.
{: .notice--success}

# Introduction
{% include start-box.html class="math-box"%}
NumPy (Numerical Python) is a fundamental package for scientific computing in Python, offering powerful advantages for multi-dimensional array calculations. 
It's essential for anyone working with numerical data in Python, especially in fields like data science and deep learning.

Unlike standard Python lists, where objects can be scattered in memory, NumPy arrays store elements of the same data type contiguously. 
This efficient memory layout makes NumPy arrays significantly faster and more convenient for numerical operations, allowing you to perform complex calculations on entire arrays at once. NumPy's capabilities for handling multi-dimensional arrays are particularly well-developed.
{% include end-box.html %}


# 1.Array
{% include start-box.html class="math-box"%}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**List vs. Array**<br>

**List (`a = [1, 2, 3]`)**
- **Stores References**<br>
 A list doesn't store the actual data (like the numbers 1, 2, 3) directly inside itself. Instead, it stores references (memory addresses or pointers) to the objects that contain the data.
- **Scattered Objects**<br>
The actual integer objects (1, 2, 3) can be located anywhere in your computer's memory, potentially far apart from each other. The list just keeps track of where to find them.
- **Flexibility**<br>
This allows lists to hold items of different data types (e.g., `[1, "hello", True]`), as it just stores references to various object types.

**Array (`b = np.array([4, 5, 6])`)**
- **Stores Data Directly**<br>
A NumPy array stores the actual data values (4, 5, 6) directly within a contiguous block of memory. All the elements are packed together one after the other.
- **Homogeneous Type**<br>
Because the data is stored directly and contiguously, all elements in a NumPy array must be of the same data type (e.g., all integers or all floating-point numbers).
- **Efficiency**<br>
This contiguous memory layout makes NumPy arrays much more memory-efficient and significantly faster for numerical computations compared to Python lists. Operations can often be performed on the entire block of data at once (vectorization).
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Multi-dimensional Arrays**<br>
<figure style="display: flex; flex-direction: column; align-items: center; margin-top: 0.5em; margin-bottom: 0.5em;">
  <img src="../images/2025-10-21-Python_14/Fig_1.png" alt="" 
       style="width: 70%; height: auto;">
   <figcaption style="font-size: 20px; margin-top: -0.5em;">
   </figcaption>
</figure> 

**`ndim` (Number of Dimensions)**: This tells you how many axes the array has.

**`shape`**: This is a tuple that describes the size of the array along each dimension (axis). The number of elements in the shape tuple is equal to `ndim`.

**`axis`**: This refers to a specific dimension of the array. Axes are numbered starting from 0. When we increase dimensionality (e.g., stack 1D arrays to make a 2D array), the new axis added is axis 0.
{% include end-box.html %}
{% include end-box.html %}

# 2.Array Creation
{% include start-box.html class="math-box"%}

## 2-1) Array Dimension, Shape, and Size
We can create arrays from Python lists. 

Key attributes of an array include:
- `ndim`: The number of dimensions (axes) of the array.

- `shape`: A tuple indicating the size of the array along each dimension.

- `size`: The total number of elements in the array.

```python
import numpy as np # Typically imported as np

# Create a 1D array from a list
a = np.array([1, 2, 3, 4])
print(a.ndim, a.shape, a.size)

# Create a 2D array
b = np.array([[1, 2, 3], [4, 5, 6]])
print(b.ndim, b.shape, b.size)

# Create a 3D array
c = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
print(c.ndim, c.shape, c.size)
```
```python
1 (4,) 4
2 (2, 3) 6
3 (2, 2, 3) 12
```

## 2-2) Creating Arrays with Specific Structures
NumPy provides various functions to create arrays in different ways:
- `np.zeros((a, b))`: Creates an array of shape `(a, b)` filled with `0.0`.
- `np.ones((a, b))`: Creates an array of shape `(a, b)` filled with `1.0`.
- `np.full((a, b), c)`: Creates an array of shape `(a, b)` filled with the value `c`.
- `np.eye(a)`: Creates a square `a` $\times$ `a` identity matrix (1.0 on the diagonal, 0.0 elsewhere).
- `np.random.random((a, b))`: Creates an array of shape `(a, b)` filled with random floats between `0.0 <= x < 1.0`.
- `np.arange(a, b, c)`: Creates a 1D array with values from `a` up to (but not including) `b`, with a step of `c`. Similar to Python's `range()`.
- `np.linspace(a, b, num=c)`: Creates a 1D array with c evenly spaced values starting from a and ending at b (inclusive).
- `np.ones_like(a)`: Creates an array with the same shape as `a`, filled with `1.0`.
- `np.zeros_like(a)`: Creates an array with the same shape as `a`, filled with `0.0`.
- `np.empty(shape)`: Creates an array with the given shape without initializing its elements. The values will be unpredictable.
- `np.empty_like(a)`: Creates an array with the same shape as a without initializing its elements.
- `np.full_like(a, fill_value)`: Creates an array with the same shape as `a`, filled with `fill_value`.

```python
import numpy as np

# Array of shape (2, 1) filled with 0.0
a = np.zeros((2, 1))
print("zeros:\n", a)

# Array of shape (1, 2) filled with 1.0
b = np.ones((1, 2))
print("\nones:\n", b)

# Array filled with the value 7
c = np.full((2, 2), 7)
print("\nfull:\n", c)

# 3x3 Identity matrix
d = np.eye(3)
print("\neye:\n", d)

# 2x2 Array with random floats
e = np.random.random((2, 2))
print("\nrandom.random:\n", e)

# Array similar to range(2, 9, 2)
f = np.arange(2, 9, 2)
print("\narange:\n", f)

# 5 evenly spaced numbers from 0 to 10
g = np.linspace(0, 10, num=5)
print("\nlinspace:\n", g)

# Array like 'g' filled with ones
h = np.ones_like(g)
print("\nones_like:\n", h)

# Array like 'g' filled with zeros
i = np.zeros_like(g)
print("\nzeros_like:\n", i)

# Uninitialized 2x4 array
j = np.empty((2, 4))
print("\nempty:\n", j)

# Uninitialized array like 'j'
k = np.empty_like(j)
print("\nempty_like:\n", k)

# Array like 'b' filled with 5
l = np.full_like(b, 5)
print("\nfull_like:\n", l)
```
```python
zeros:
 [[0.]
 [0.]]

ones:
 [[1. 1.]]

full:
 [[7 7]
 [7 7]]

eye:
 [[1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]

random.random:
 [[0.50692048 0.10451959]
 [0.20198272 0.07831296]]

arange:
 [2 4 6 8]

linspace:
 [ 0.   2.5  5.   7.5 10. ]
...
 [0.00000000e+000 8.73508062e-321 1.33511969e-306 1.86921958e-306]]

full_like:
 [[5. 5.]]
```
{% include end-box.html %}









```python

```
```python

```



<div class="indented-paragraph" markdown="1">

</div>

{% include start-box.html class="math-box-inner" font_size="0.8em"%}

```python

```
```python

```
{% include end-box.html %}


{% include start-box.html class="math-box"%}

{% include end-box.html %}