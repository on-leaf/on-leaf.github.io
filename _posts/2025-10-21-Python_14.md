---
layout: single
title:  "14.Numpy"
category: "Python"
tag: [Python]
header:
  teaser: #../images/2025-07-08-CT_6/image-20250708184503610.png
toc: true
toc_sticky: true
toc_label: CONTENTS
toc_icon: "fa-solid fa-seedling" # More icons: https://fontawesome.com/v6/search?ic=free
author_profile: false
sidebar:
    nav: "counts"
search: true # Change true to false if you don't want to have this article be searched 
redirect_from:
    - /Python/Python_14
use_math: true
---

**[Reference]** <br>
$\bullet$ [홍정모의 파이썬 프로그래밍 추월코스](https://www.honglab.ai/courses/python)<br>
This post is written based on above lecture.<br>
All contents in this post are not the same with above lecture.<br>
Please show the detail at the his lecture.
{: .notice--success}

# Introduction
{% include start-box.html class="math-box"%}
NumPy (Numerical Python) is a fundamental package for scientific computing in Python, offering powerful advantages for multi-dimensional array calculations. 
It's essential for anyone working with numerical data in Python, especially in fields like data science and deep learning.

Unlike standard Python lists, where objects can be scattered in memory, NumPy arrays store elements of the same data type contiguously. 
This efficient memory layout makes NumPy arrays significantly faster and more convenient for numerical operations, allowing you to perform complex calculations on entire arrays at once. NumPy's capabilities for handling multi-dimensional arrays are particularly well-developed.
{% include end-box.html %}


# 1.Array
{% include start-box.html class="math-box"%}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**List vs. Array**<br>

**List (`a = [1, 2, 3]`)**
- **Stores References**<br>
 A list doesn't store the actual data (like the numbers 1, 2, 3) directly inside itself. Instead, it stores references (memory addresses or pointers) to the objects that contain the data.
- **Scattered Objects**<br>
The actual integer objects (1, 2, 3) can be located anywhere in your computer's memory, potentially far apart from each other. The list just keeps track of where to find them.
- **Flexibility**<br>
This allows lists to hold items of different data types (e.g., `[1, "hello", True]`), as it just stores references to various object types.

**Array (`b = np.array([4, 5, 6])`)**
- **Stores Data Directly**<br>
A NumPy array stores the actual data values (4, 5, 6) directly within a contiguous block of memory. All the elements are packed together one after the other.
- **Homogeneous Type**<br>
Because the data is stored directly and contiguously, all elements in a NumPy array must be of the same data type (e.g., all integers or all floating-point numbers).
- **Efficiency**<br>
This contiguous memory layout makes NumPy arrays much more memory-efficient and significantly faster for numerical computations compared to Python lists. Operations can often be performed on the entire block of data at once (vectorization).
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Multi-dimensional Arrays**<br>
<figure style="display: flex; flex-direction: column; align-items: center; margin-top: 0.5em; margin-bottom: 0.5em;">
  <img src="../images/2025-10-21-Python_14/Fig_1.png" alt="" 
       style="width: 70%; height: auto;">
   <figcaption style="font-size: 20px; margin-top: -0.5em;">
   </figcaption>
</figure> 

**`ndim` (Number of Dimensions)**: This tells you how many axes the array has.

**`shape`**: This is a tuple that describes the size of the array along each dimension (axis). The number of elements in the shape tuple is equal to `ndim`.

**`axis`**: This refers to a specific dimension of the array. Axes are numbered starting from 0. When we increase dimensionality (e.g., stack 1D arrays to make a 2D array), the new axis added is axis 0.
{% include end-box.html %}
{% include end-box.html %}

# 2.Array Creation
{% include start-box.html class="math-box"%}

## 2-1) Array Dimension, Shape, and Size
We can create arrays from Python lists. 

Key attributes of an array include:
- `ndim`: The number of dimensions (axes) of the array.

- `shape`: A tuple indicating the size of the array along each dimension.

- `size`: The total number of elements in the array.

```python
import numpy as np # Typically imported as np

# Create a 1D array from a list
a = np.array([1, 2, 3, 4])
print(a.ndim, a.shape, a.size)

# Create a 2D array
b = np.array([[1, 2, 3], [4, 5, 6]])
print(b.ndim, b.shape, b.size)

# Create a 3D array
c = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
print(c.ndim, c.shape, c.size)
```
```python
1 (4,) 4
2 (2, 3) 6
3 (2, 2, 3) 12
```

## 2-2) Creating Arrays with Specific Structures
NumPy provides various functions to create arrays in different ways:

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.zeros((a, b))`: Creates an array of shape `(a, b)` filled with `0.0`.
```python
# Array of shape (2, 1) filled with 0.0
import numpy as np

a = np.zeros((2, 1))
print("zeros:\n", a)
```
```python
zeros:
 [[0.]
 [0.]]
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.ones((a, b))`: Creates an array of shape `(a, b)` filled with `1.0`.
```python
# Array of shape (1, 2) filled with 1.0
import numpy as np

b = np.ones((1, 2))
print("ones:\n", b)
```
```python
ones:
 [[1. 1.]]
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.full((a, b), c)`: Creates an array of shape `(a, b)` filled with the value `c`.
```python
# Array filled with the value 7
import numpy as np

c = np.full((2, 2), 7)
print("full:\n", c)
```
```python
full:
 [[7 7]
 [7 7]]
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.eye(a)`: Creates a square `a` $\times$ `a` identity matrix (1.0 on the diagonal, 0.0 elsewhere).
```python
# 3x3 Identity matrix
import numpy as np

d = np.eye(3)
print("eye:\n", d)
```
```python
eye:
 [[1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.random.random((a, b))`: Creates an array of shape `(a, b)` filled with random floats between `0.0 <= x < 1.0`.
```python
# 2x2 Array with random floats
import numpy as np

e = np.random.random((2, 2))
print("random.random:\n", e)
```
```python
random.random:
 [[0.50692048 0.10451959]
 [0.20198272 0.07831296]]
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.arange(a, b, c)`: Creates a 1D array with values from `a` up to (but not including) `b`, with a step of `c`. Similar to Python's `range()`.
```python
# Array similar to range(2, 9, 2)
import numpy as np

f = np.arange(2, 9, 2)
print("arange:\n", f)
```
```python
arange:
 [2 4 6 8]
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.linspace(a, b, num=c)`: Creates a 1D array with c evenly spaced values starting from a and ending at b (inclusive).
```python
# 5 evenly spaced numbers from 0 to 10
import numpy as np

g = np.linspace(0, 10, num=5)
print("linspace:\n", g)
```
```python
linspace:
 [ 0.   2.5  5.   7.5 10. ]
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.ones_like(a)`: Creates an array with the same shape as `a`, filled with `1.0`.
```python
# Array like 'g' filled with ones
import numpy as np

h = np.ones_like(g)
print("ones_like:\n", h)
```
```python
ones_like:
 [1. 1. 1. 1. 1.]
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.zeros_like(a)`: Creates an array with the same shape as `a`, filled with `0.0`.
```python
# Array like 'g' filled with zeros
import numpy as np

i = np.zeros_like(g)
print("zeros_like:\n", i)
```
```python
zeros_like:
 [0. 0. 0. 0. 0.]
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.empty(shape)`: Creates an array with the given shape without initializing its elements. The values will be unpredictable.
```python
# Uninitialized 2x4 array
import numpy as np

j = np.empty((2, 4))
print("empty:\n", j)
```
```python
empty:
 [[0.00000000e+000 0.00000000e+000 0.00000000e+000 0.00000000e+000]
 [0.00000000e+000 8.73508062e-321 1.33511969e-306 1.86921958e-306]]
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.empty_like(a)`: Creates an array with the same shape as a without initializing its elements.
```python
# Uninitialized array like 'j'
import numpy as np

k = np.empty_like(j)
print("empty_like:\n", k)
```
```python
empty_like:
 [[0.00000000e+000 0.00000000e+000 0.00000000e+000 0.00000000e+000]
 [0.00000000e+000 8.73508062e-321 1.33511969e-306 1.86921958e-306]]
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.full_like(a, fill_value)`: Creates an array with the same shape as `a`, filled with `fill_value`.
```python
# Array like 'b' filled with 5
import numpy as np

l = np.full_like(b, 5)
print("full_like:\n", l)
```
```python
full_like:
 [[5. 5.]]
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
Because NumPy allows operations on the array object itself, it's more convenient than using a list comprehension when applying the same calculation to multiple values.
```python
import numpy as np

my_list = [4, 5, 6]

# Using a list comprehension
new_list_1 = [x*2+1 for x in my_list]

# Using a NumPy array
my_array = np.array(my_list)
# The operation is applied element-wise to the entire array
new_array_1 = my_array*2 + 1 

print(new_list_1)
print(new_array_1)
```
```python
[9, 11, 13]
[ 9 11 13]
```
{% include end-box.html %}

## 2-3) Array Manipulation
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**`reshape()`**<br>
We can change the shape of an array using the `reshape` method or function.

`a.reshape(newshape, order='C')` or `numpy.reshape(a, newshape, order='C')`

- `a`: The array to be reshaped.
- `newshape`: An `int` or `tuple` of `ints` defining the new shape. One dimension can be `-1`, which means its size is inferred from the array's length and the other dimensions.
- `order`: Specifies how the elements should be read and placed into the new shape.
    - `C`: (Default): C-like index order (row-major). Read/write elements row by row.
    - `F`: Fortran-like index order (column-major). Read/write elements column by column.
    - `A`: Fortran-like if `a` is Fortran contiguous in memory, C-like otherwise.

```python
import numpy as np

a = np.arange(0, 12) # [0, 1, 2, ..., 11]

# Reshape 'a' to 4 rows, 3 columns using C order (default)
b = np.reshape(a, (4, 3), 'C')
print(b, end='\n\n')

# Reshape 'a' to 4 rows, 3 columns using Fortran order
c = np.reshape(a, (4, 3), 'F')
print(c, end='\n\n')

# Reshape 'c' using order 'A' (will likely be C order here)
d = np.reshape(c, (4, 3), 'A')
print(d, end='\n\n')

# Use -1 to flatten the array back to 1D
e = np.reshape(a, -1)
print(e, end='\n\n')
```
```python
[[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]

[[ 0  4  8]
 [ 1  5  9]
 [ 2  6 10]
 [ 3  7 11]]

[[ 0  1  2]  # Output for 'A' depends on memory layout, often C
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]] 

[ 0  1  2  3  4  5  6  7  8  9 10 11]
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**`ravel()`**<br>
We can flatten a multi-dimensional array into a 1D array using the `ravel` method or function.

`a.ravel(order='C')` or `numpy.ravel(a, order='C')`

- `a`: The array to be flattened.
- `order`: Specifies the order in which elements are read.
    - 'C' (Default): C order (row-major).
    - 'F': Fortran order (column-major).
    - 'A': Fortran-like if a is Fortran contiguous, C-like otherwise.
    - 'K': Read elements in the order they appear in memory.

```python
import numpy as np

a = np.arange(0, 12).reshape((4, 3))
print("Array a")
print(a, end='\n\n')

print("Array a after ravel with order C")
b = np.ravel(a, 'C')
print(b, end='\n\n')

print("Array a after ravel with order F")
c = np.ravel(a, 'F')
print(c, end='\n\n')

print("Array a after ravel with order A")
d = np.ravel(a, 'A')
print(d, end='\n\n')

print("Array a after ravel with order K")
k = np.ravel(a, 'K')
print(k)
```
```python
Array a
[[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]

Array a after ravel with order C
[ 0  1  2  3  4  5  6  7  8  9 10 11]

Array a after ravel with order F
[ 0  3  6  9  1  4  7 10  2  5  8 11]

Array a after ravel with order A
[ 0  1  2  3  4  5  6  7  8  9 10 11]

Array a after ravel with order K
[ 0  1  2  3  4  5  6  7  8  9 10 11]
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**`flatten()`**<br>
Returns a **copy** of the array collapsed into one dimension.

`a.flatten(order='C')`

- `np.flatten()` does not exist.
- `a`: Array to be flattened.
- `order: {'C', 'F', 'A', 'K'}`, optional. Order to read elements.

```python
import numpy as np

a = np.arange(0, 12).reshape((4, 3))
print("Array a")
print(a, end='\n\n')

print("Array a after flatten with order C")
b = a.flatten('C')
print(b, end='\n\n')

print("Array a after flatten with order F")
c = a.flatten('F')
print(c, end='\n\n')

print("Array a after flatten with order A")
d = a.flatten('A')
print(d, end='\n\n')

print("Array a after flatten with order K")
k = a.flatten('K')
print(k)
```
```python
Array a
[[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]

Array a after flatten with order C
[ 0  1  2  3  4  5  6  7  8  9 10 11]

Array a after flatten with order F
[ 0  3  6  9  1  4  7 10  2  5  8 11]

Array a after flatten with order A
[ 0  1  2  3  4  5  6  7  8  9 10 11]

Array a after flatten with order K
[ 0  1  2  3  4  5  6  7  8  9 10 11]
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Comparison: `reshape(-1)` vs. `ravel()` vs. `flatten()`**<br>
- `reshape(-1)` and `ravel()`<br>
:These often return a **view** of the original array whenever possible, meaning they don't create a new copy of the data. If the original array is modified, the view returned by reshape or ravel will reflect those changes.

- `flatten()`<br>
:This method always returns a **copy** of the data. Modifying the original array will **not affect** the array returned by `flatten`.

```python
import numpy as np

a = np.arange(0, 12).reshape((4, 3))
print("Array a")
print(a)
print("id:", id(a), end='\n\n')

b = a.reshape(-1)
print("Array a with reshape(-1)")
print(b)
print("id:", id(b), end='\n\n') # Often a different ID, but may share data

c = a.ravel('C')
print("Array a with ravel()")
print(c)
print("id:", id(c), end='\n\n') # Often a different ID, but may share data

d = a.flatten('C')
print("Array a with flatten()")
print(d)
print("id:", id(d), end='\n\n') # Always a different ID

# Modify the original array 'a'
a *= 2

print("Array a with reshape(-1) after value change")
print(b)
print("id:", id(b), end='\n\n')

print("Array a with ravel() after value change")
print(c)
print("id:", id(c), end='\n\n')

print("Array a with flatten() after value change")
print(d)
print("id:", id(d))
```
```python
Array a
[[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]
id: 1568335326896

Array a with reshape(-1)
[ 0  1  2  3  4  5  6  7  8  9 10 11]
id: 1568329920944

Array a with ravel()
[ 0  1  2  3  4  5  6  7  8  9 10 11]
id: 1568335327280

Array a with flatten()
[ 0  1  2  3  4  5  6  7  8  9 10 11]
id: 1568334507696

Array a with reshape(-1) after value change
[ 0  2  4  6  8 10 12 14 16 18 20 22]
id: 1568329920944

Array a with ravel() after value change
[ 0  2  4  6  8 10 12 14 16 18 20 22]
id: 1568335327280

Array a with flatten() after value change
[ 0  1  2  3  4  5  6  7  8  9 10 11]
id: 1568334507696
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**`concatenate()`**<br>
Joins a sequence of arrays (lists, tuples, etc.) along an existing axis.

`numpy.concatenate((a1, a2, ...), axis=0, out=None, dtype=None, casting="same_kind")`

- `a1, a2, ...`: `sequence of array_like` The arrays must have the same shape, except in the dimension corresponding to `axis`.
- `axis`: `int, optional` The axis along which the arrays will be joined. If `axis` is `None`, arrays are flattened before use. Default is `0`.
- `out`: `ndarray`, `optional` If provided, the destination to place the result. The shape must be correct.
- `dtype`: `str` or `dtype`, `optional` If provided, the destination array will have this `dtype`.
- `casting`: `{'no', 'equiv', 'safe', 'same_kind', 'unsafe'}`, `optional` Controls what kind of data casting may occur. Defaults to 'same_kind'.

```python
import numpy as np

# Concatenate 2 dim array
a = np.ones((2, 3))
b = np.zeros((2, 3))

# Concatenate along axis 0 (stacking rows)
print("Concatenate of a&b by axis 0")
print(np.concatenate((a, b), axis=0), end='\n\n')

# Concatenate along axis 1 (joining columns)
print("Concatenate of a&b by axis 1")
print(np.concatenate((a, b), axis=1))
```
```python
Concatenate of a&b by axis 0
[[1. 1. 1.]
 [1. 1. 1.]
 [0. 0. 0.]
 [0. 0. 0.]]

Concatenate of a&b by axis 1
[[1. 1. 1. 0. 0. 0.]
 [1. 1. 1. 0. 0. 0.]]
```

```python
import numpy as np

# Concatenate 3 dim array
a = np.ones((2, 2, 3))
b = np.zeros((2, 2, 3))

print("Concatenate of a&b by axis 0")
print(np.concatenate((a, b), axis=0), end='\n\n')

print("Concatenate of a&b by axis 1")
print(np.concatenate((a, b), axis=1), end='\n\n')

print("Concatenate of a&b by axis 2")
print(np.concatenate((a, b), axis=2))
```
```python
Concatenate of a&b by axis 0
[[[1. 1. 1.]
  [1. 1. 1.]]

 [[1. 1. 1.]
  [1. 1. 1.]]

 [[0. 0. 0.]
  [0. 0. 0.]]

 [[0. 0. 0.]
  [0. 0. 0.]]]


Concatenate of a&b by axis 1
[[[1. 1. 1.]
  [1. 1. 1.]
  [0. 0. 0.]
  [0. 0. 0.]]

 [[1. 1. 1.]
  [1. 1. 1.]
  [0. 0. 0.]
  [0. 0. 0.]]]


Concatenate of a&b by axis 2
[[[1. 1. 1. 0. 0. 0.]
  [1. 1. 1. 0. 0. 0.]]

 [[1. 1. 1. 0. 0. 0.]
  [1. 1. 1. 0. 0. 0.]]]
```
{% include end-box.html %}

**NumPy Stacking Functions**<br>
NumPy provides convenient functions, vstack and hstack, for stacking arrays vertically and horizontally, respectively. These are essentially shortcuts for using numpy.concatenate along specific axes.
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**`vstack()`**<br>
Stack arrays in sequence **vertically** (row-wise). This is equivalent to concatenation along the **first axis** (axis=0).

`numpy.vstack(tup, dtype=None, casting='same_kind')`

- `tup`: `sequence of ndarrays`
    :The arrays to stack. They must have the same shape along all but the first axis.

- `dtype`: `str` or `dtype`
    :If provided, the destination array will have this `dtype`.

- `casting`: `{'no', 'equiv', 'safe', 'same_kind', 'unsafe'}`, `optional`
    :Controls what kind of data casting may occur. Defaults to `'same_kind'`.

```python
import numpy as np

# vstack of 2 dim array
a = np.ones((2, 3))
b = np.zeros((2, 3))

print("vstack of a&b")
print("shape:", np.vstack((a, b)).shape)
print(np.vstack((a, b)), end='\n\n')

# Equivalent concatenate operation
print("concatenate of a&b by axis = 0")
print("shape:", np.concatenate((a, b), axis=0).shape)
print(np.concatenate((a, b), axis=0))
```
```python
vstack of a&b
shape: (4, 3)
[[1. 1. 1.]
 [1. 1. 1.]
 [0. 0. 0.]
 [0. 0. 0.]]

concatenate of a&b by axis = 0
shape: (4, 3)
[[1. 1. 1.]
 [1. 1. 1.]
 [0. 0. 0.]
 [0. 0. 0.]]
```

```python
# vstack of 3 dim array
a = np.ones((2, 2, 3))
b = np.zeros((2, 2, 3))

print("vstack of a&b")
print("shape:", np.vstack((a, b)).shape)
print(np.vstack((a, b)), end='\n\n')

# Equivalent concatenate operation
print("concatenate of a&b by axis = 0") # Corrected from axis=1 in image
print("shape:", np.concatenate((a, b), axis=0).shape)
print(np.concatenate((a, b), axis=0))
```
```python
vstack of a&b
shape: (4, 2, 3)
[[[1. 1. 1.]
  [1. 1. 1.]]

 [[1. 1. 1.]
  [1. 1. 1.]]

 [[0. 0. 0.]
  [0. 0. 0.]]

 [[0. 0. 0.]
  [0. 0. 0.]]]

concatenate of a&b by axis = 0
shape: (4, 2, 3)
[[[1. 1. 1.]
  [1. 1. 1.]]

 [[1. 1. 1.]
  [1. 1. 1.]]

 [[0. 0. 0.]
  [0. 0. 0.]]

 [[0. 0. 0.]
  [0. 0. 0.]]]
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**`hstack()`**<br>
Stack arrays in sequence **horizontally** (column-wise). This is equivalent to concatenation along the **second axis** (`axis=1`).

`numpy.hstack(tup, dtype=None, casting='same_kind')`

- `tup`: `sequence of ndarrays`
    :The arrays to stack. They must have the same shape along all but the second axis.
- `dtype`: `str` or `dtype`
    :If provided, the destination array will have this `dtype`.
- `casting`: `{'no', 'equiv', 'safe', 'same_kind', 'unsafe'}`, `optional`
    :Controls what kind of data casting may occur. Defaults to `'same_kind'`.

```python
# hstack of 2 dim array
a = np.ones((2, 3))
b = np.zeros((2, 3))

print("hstack of a&b")
print("shape:", np.hstack((a, b)).shape)
print(np.hstack((a, b)), end='\n\n')

# Equivalent concatenate operation
print("concatenate of a&b by axis = 1")
print("shape:", np.concatenate((a, b), axis=1).shape)
print(np.concatenate((a, b), axis=1))
```
```python
hstack of a&b
shape: (2, 6)
[[1. 1. 1. 0. 0. 0.]
 [1. 1. 1. 0. 0. 0.]]

concatenate of a&b by axis = 1
shape: (2, 6)
[[1. 1. 1. 0. 0. 0.]
 [1. 1. 1. 0. 0. 0.]]
```

```python
# hstack of 3 dim array
a = np.ones((2, 2, 3))
b = np.zeros((2, 2, 3))

print("hstack of a&b")
print("shape:", np.hstack((a, b)).shape)
print(np.hstack((a, b)), end='\n\n')

# Equivalent concatenate operation
print("concatenate of a&b by axis = 1")
print("shape:", np.concatenate((a, b), axis=1).shape)
print(np.concatenate((a, b), axis=1))
```
```python
hstack of a&b
shape: (2, 4, 3)
[[[1. 1. 1.]
  [1. 1. 1.]
  [0. 0. 0.]
  [0. 0. 0.]]

 [[1. 1. 1.]
  [1. 1. 1.]
  [0. 0. 0.]
  [0. 0. 0.]]]

concatenate of a&b by axis = 1
shape: (2, 4, 3)
[[[1. 1. 1.]
  [1. 1. 1.]
  [0. 0. 0.]
  [0. 0. 0.]]

 [[1. 1. 1.]
  [1. 1. 1.]
  [0. 0. 0.]
  [0. 0. 0.]]]
```
{% include end-box.html %}

{% include end-box.html %}








```python

```
```python

```



<div class="indented-paragraph" markdown="1">

</div>

{% include start-box.html class="math-box-inner" font_size="0.8em"%}

```python

```
```python

```
{% include end-box.html %}


{% include start-box.html class="math-box"%}

{% include end-box.html %}