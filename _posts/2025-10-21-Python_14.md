---
layout: single
title:  "14.Numpy"
category: "Python"
tag: [Python]
header:
  teaser: #../images/2025-07-08-CT_6/image-20250708184503610.png
toc: true
toc_sticky: true
toc_label: CONTENTS
toc_icon: "fa-solid fa-seedling" # More icons: https://fontawesome.com/v6/search?ic=free
author_profile: false
sidebar:
    nav: "counts"
search: true # Change true to false if you don't want to have this article be searched 
redirect_from:
    - /Python/Python_14
use_math: true
---

**[Reference]** <br>
$\bullet$ [홍정모의 파이썬 프로그래밍 추월코스](https://www.honglab.ai/courses/python)<br>
This post is written based on above lecture.<br>
All contents in this post are not the same with above lecture.<br>
Please show the detail at the his lecture.
{: .notice--success}

# Introduction
{% include start-box.html class="math-box"%}
NumPy (Numerical Python) is a fundamental package for scientific computing in Python, offering powerful advantages for multi-dimensional array calculations. 
It's essential for anyone working with numerical data in Python, especially in fields like data science and deep learning.

Unlike standard Python lists, where objects can be scattered in memory, NumPy arrays store elements of the same data type contiguously. 
This efficient memory layout makes NumPy arrays significantly faster and more convenient for numerical operations, allowing you to perform complex calculations on entire arrays at once. NumPy's capabilities for handling multi-dimensional arrays are particularly well-developed.
{% include end-box.html %}


# 1.Array
{% include start-box.html class="math-box"%}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**List vs. Array**<br>

**List (`a = [1, 2, 3]`)**
- **Stores References**<br>
 A list doesn't store the actual data (like the numbers 1, 2, 3) directly inside itself. Instead, it stores references (memory addresses or pointers) to the objects that contain the data.
- **Scattered Objects**<br>
The actual integer objects (1, 2, 3) can be located anywhere in your computer's memory, potentially far apart from each other. The list just keeps track of where to find them.
- **Flexibility**<br>
This allows lists to hold items of different data types (e.g., `[1, "hello", True]`), as it just stores references to various object types.

**Array (`b = np.array([4, 5, 6])`)**
- **Stores Data Directly**<br>
A NumPy array stores the actual data values (4, 5, 6) directly within a contiguous block of memory. All the elements are packed together one after the other.
- **Homogeneous Type**<br>
Because the data is stored directly and contiguously, all elements in a NumPy array must be of the same data type (e.g., all integers or all floating-point numbers).
- **Efficiency**<br>
This contiguous memory layout makes NumPy arrays much more memory-efficient and significantly faster for numerical computations compared to Python lists. Operations can often be performed on the entire block of data at once (vectorization).
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Multi-dimensional Arrays**<br>
<figure style="display: flex; flex-direction: column; align-items: center; margin-top: 0.5em; margin-bottom: 0.5em;">
  <img src="../images/2025-10-21-Python_14/Fig_1.png" alt="" 
       style="width: 70%; height: auto;">
   <figcaption style="font-size: 20px; margin-top: -0.5em;">
   </figcaption>
</figure> 

**`ndim` (Number of Dimensions)**: This tells you how many axes the array has.

**`shape`**: This is a tuple that describes the size of the array along each dimension (axis). The number of elements in the shape tuple is equal to `ndim`.

**`axis`**: This refers to a specific dimension of the array. Axes are numbered starting from 0. When we increase dimensionality (e.g., stack 1D arrays to make a 2D array), the new axis added is axis 0.
{% include end-box.html %}
{% include end-box.html %}

# 2.Array Creation
{% include start-box.html class="math-box"%}

## 2-1) Array Dimension, Shape, and Size
We can create arrays from Python lists. 

Key attributes of an array include:
- `ndim`: The number of dimensions (axes) of the array.

- `shape`: A tuple indicating the size of the array along each dimension.

- `size`: The total number of elements in the array.

```python
import numpy as np # Typically imported as np

# Create a 1D array from a list
a = np.array([1, 2, 3, 4])
print(a.ndim, a.shape, a.size)

# Create a 2D array
b = np.array([[1, 2, 3], [4, 5, 6]])
print(b.ndim, b.shape, b.size)

# Create a 3D array
c = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
print(c.ndim, c.shape, c.size)
```
```python
1 (4,) 4
2 (2, 3) 6
3 (2, 2, 3) 12
```

## 2-2) Creating Arrays with Specific Structures
NumPy provides various functions to create arrays in different ways:

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.zeros((a, b))`: Creates an array of shape `(a, b)` filled with `0.0`.
```python
# Array of shape (2, 1) filled with 0.0
import numpy as np

a = np.zeros((2, 1))
print("zeros:\n", a)
```
```python
zeros:
 [[0.]
 [0.]]
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.ones((a, b))`: Creates an array of shape `(a, b)` filled with `1.0`.
```python
# Array of shape (1, 2) filled with 1.0
import numpy as np

b = np.ones((1, 2))
print("ones:\n", b)
```
```python
ones:
 [[1. 1.]]
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.full((a, b), c)`: Creates an array of shape `(a, b)` filled with the value `c`.
```python
# Array filled with the value 7
import numpy as np

c = np.full((2, 2), 7)
print("full:\n", c)
```
```python
full:
 [[7 7]
 [7 7]]
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.eye(a)`: Creates a square `a` $\times$ `a` identity matrix (1.0 on the diagonal, 0.0 elsewhere).
```python
# 3x3 Identity matrix
import numpy as np

d = np.eye(3)
print("eye:\n", d)
```
```python
eye:
 [[1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.random.random((a, b))`: Creates an array of shape `(a, b)` filled with random floats between `0.0 <= x < 1.0`.
```python
# 2x2 Array with random floats
import numpy as np

e = np.random.random((2, 2))
print("random.random:\n", e)
```
```python
random.random:
 [[0.50692048 0.10451959]
 [0.20198272 0.07831296]]
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.arange(a, b, c)`: Creates a 1D array with values from `a` up to (but not including) `b`, with a step of `c`. Similar to Python's `range()`.
```python
# Array similar to range(2, 9, 2)
import numpy as np

f = np.arange(2, 9, 2)
print("arange:\n", f)
```
```python
arange:
 [2 4 6 8]
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.linspace(a, b, num=c)`: Creates a 1D array with c evenly spaced values starting from a and ending at b (inclusive).
```python
# 5 evenly spaced numbers from 0 to 10
import numpy as np

g = np.linspace(0, 10, num=5)
print("linspace:\n", g)
```
```python
linspace:
 [ 0.   2.5  5.   7.5 10. ]
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.ones_like(a)`: Creates an array with the same shape as `a`, filled with `1.0`.
```python
# Array like 'g' filled with ones
import numpy as np

h = np.ones_like(g)
print("ones_like:\n", h)
```
```python
ones_like:
 [1. 1. 1. 1. 1.]
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.zeros_like(a)`: Creates an array with the same shape as `a`, filled with `0.0`.
```python
# Array like 'g' filled with zeros
import numpy as np

i = np.zeros_like(g)
print("zeros_like:\n", i)
```
```python
zeros_like:
 [0. 0. 0. 0. 0.]
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.empty(shape)`: Creates an array with the given shape without initializing its elements. The values will be unpredictable.
```python
# Uninitialized 2x4 array
import numpy as np

j = np.empty((2, 4))
print("empty:\n", j)
```
```python
empty:
 [[0.00000000e+000 0.00000000e+000 0.00000000e+000 0.00000000e+000]
 [0.00000000e+000 8.73508062e-321 1.33511969e-306 1.86921958e-306]]
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.empty_like(a)`: Creates an array with the same shape as a without initializing its elements.
```python
# Uninitialized array like 'j'
import numpy as np

k = np.empty_like(j)
print("empty_like:\n", k)
```
```python
empty_like:
 [[0.00000000e+000 0.00000000e+000 0.00000000e+000 0.00000000e+000]
 [0.00000000e+000 8.73508062e-321 1.33511969e-306 1.86921958e-306]]
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`np.full_like(a, fill_value)`: Creates an array with the same shape as `a`, filled with `fill_value`.
```python
# Array like 'b' filled with 5
import numpy as np

l = np.full_like(b, 5)
print("full_like:\n", l)
```
```python
full_like:
 [[5. 5.]]
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
Because NumPy allows operations on the array object itself, it's more convenient than using a list comprehension when applying the same calculation to multiple values.
```python
import numpy as np

my_list = [4, 5, 6]

# Using a list comprehension
new_list_1 = [x*2+1 for x in my_list]

# Using a NumPy array
my_array = np.array(my_list)
# The operation is applied element-wise to the entire array
new_array_1 = my_array*2 + 1 

print(new_list_1)
print(new_array_1)
```
```python
[9, 11, 13]
[ 9 11 13]
```
{% include end-box.html %}

## 2-3) Array Manipulation
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**`reshape()`**<br>
We can change the shape of an array using the `reshape` method or function.

`a.reshape(newshape, order='C')` or `numpy.reshape(a, newshape, order='C')`

- `a`: The array to be reshaped.
- `newshape`: An `int` or `tuple` of `ints` defining the new shape. One dimension can be `-1`, which means its size is inferred from the array's length and the other dimensions.
- `order`: Specifies how the elements should be read and placed into the new shape.
    - `C`: (Default): C-like index order (row-major). Read/write elements row by row.
    - `F`: Fortran-like index order (column-major). Read/write elements column by column.
    - `A`: Fortran-like if `a` is Fortran contiguous in memory, C-like otherwise.

```python
import numpy as np

a = np.arange(0, 12) # [0, 1, 2, ..., 11]

# Reshape 'a' to 4 rows, 3 columns using C order (default)
b = np.reshape(a, (4, 3), 'C')
print(b, end='\n\n')

# Reshape 'a' to 4 rows, 3 columns using Fortran order
c = np.reshape(a, (4, 3), 'F')
print(c, end='\n\n')

# Reshape 'c' using order 'A' (will likely be C order here)
d = np.reshape(c, (4, 3), 'A')
print(d, end='\n\n')

# Use -1 to flatten the array back to 1D
e = np.reshape(a, -1)
print(e, end='\n\n')
```
```python
[[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]

[[ 0  4  8]
 [ 1  5  9]
 [ 2  6 10]
 [ 3  7 11]]

[[ 0  1  2]  # Output for 'A' depends on memory layout, often C
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]] 

[ 0  1  2  3  4  5  6  7  8  9 10 11]
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**`ravel()`**<br>
We can flatten a multi-dimensional array into a 1D array using the `ravel` method or function.

`a.ravel(order='C')` or `numpy.ravel(a, order='C')`

- `a`: The array to be flattened.
- `order`: Specifies the order in which elements are read.
    - 'C' (Default): C order (row-major).
    - 'F': Fortran order (column-major).
    - 'A': Fortran-like if a is Fortran contiguous, C-like otherwise.
    - 'K': Read elements in the order they appear in memory.

```python
import numpy as np

a = np.arange(0, 12).reshape((4, 3))
print("Array a")
print(a, end='\n\n')

print("Array a after ravel with order C")
b = np.ravel(a, 'C')
print(b, end='\n\n')

print("Array a after ravel with order F")
c = np.ravel(a, 'F')
print(c, end='\n\n')

print("Array a after ravel with order A")
d = np.ravel(a, 'A')
print(d, end='\n\n')

print("Array a after ravel with order K")
k = np.ravel(a, 'K')
print(k)
```
```python
Array a
[[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]

Array a after ravel with order C
[ 0  1  2  3  4  5  6  7  8  9 10 11]

Array a after ravel with order F
[ 0  3  6  9  1  4  7 10  2  5  8 11]

Array a after ravel with order A
[ 0  1  2  3  4  5  6  7  8  9 10 11]

Array a after ravel with order K
[ 0  1  2  3  4  5  6  7  8  9 10 11]
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**`flatten()`**<br>
Returns a **copy** of the array collapsed into one dimension.

`a.flatten(order='C')`

- `np.flatten()` does not exist.
- `a`: Array to be flattened.
- `order: {'C', 'F', 'A', 'K'}`, optional. Order to read elements.

```python
import numpy as np

a = np.arange(0, 12).reshape((4, 3))
print("Array a")
print(a, end='\n\n')

print("Array a after flatten with order C")
b = a.flatten('C')
print(b, end='\n\n')

print("Array a after flatten with order F")
c = a.flatten('F')
print(c, end='\n\n')

print("Array a after flatten with order A")
d = a.flatten('A')
print(d, end='\n\n')

print("Array a after flatten with order K")
k = a.flatten('K')
print(k)
```
```python
Array a
[[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]

Array a after flatten with order C
[ 0  1  2  3  4  5  6  7  8  9 10 11]

Array a after flatten with order F
[ 0  3  6  9  1  4  7 10  2  5  8 11]

Array a after flatten with order A
[ 0  1  2  3  4  5  6  7  8  9 10 11]

Array a after flatten with order K
[ 0  1  2  3  4  5  6  7  8  9 10 11]
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Comparison: `reshape(-1)` vs. `ravel()` vs. `flatten()`**<br>
- `reshape(-1)` and `ravel()`<br>
:These often return a **view** of the original array whenever possible, meaning they don't create a new copy of the data. If the original array is modified, the view returned by reshape or ravel will reflect those changes.

- `flatten()`<br>
:This method always returns a **copy** of the data. Modifying the original array will **not affect** the array returned by `flatten`.

```python
import numpy as np

a = np.arange(0, 12).reshape((4, 3))
print("Array a")
print(a)
print("id:", id(a), end='\n\n')

b = a.reshape(-1)
print("Array a with reshape(-1)")
print(b)
print("id:", id(b), end='\n\n') # Often a different ID, but may share data

c = a.ravel('C')
print("Array a with ravel()")
print(c)
print("id:", id(c), end='\n\n') # Often a different ID, but may share data

d = a.flatten('C')
print("Array a with flatten()")
print(d)
print("id:", id(d), end='\n\n') # Always a different ID

# Modify the original array 'a'
a *= 2

print("Array a with reshape(-1) after value change")
print(b)
print("id:", id(b), end='\n\n')

print("Array a with ravel() after value change")
print(c)
print("id:", id(c), end='\n\n')

print("Array a with flatten() after value change")
print(d)
print("id:", id(d))
```
```python
Array a
[[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]
id: 1568335326896

Array a with reshape(-1)
[ 0  1  2  3  4  5  6  7  8  9 10 11]
id: 1568329920944

Array a with ravel()
[ 0  1  2  3  4  5  6  7  8  9 10 11]
id: 1568335327280

Array a with flatten()
[ 0  1  2  3  4  5  6  7  8  9 10 11]
id: 1568334507696

Array a with reshape(-1) after value change
[ 0  2  4  6  8 10 12 14 16 18 20 22]
id: 1568329920944

Array a with ravel() after value change
[ 0  2  4  6  8 10 12 14 16 18 20 22]
id: 1568335327280

Array a with flatten() after value change
[ 0  1  2  3  4  5  6  7  8  9 10 11]
id: 1568334507696
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**`concatenate()`**<br>
Joins a sequence of arrays (lists, tuples, etc.) along an existing axis.

`numpy.concatenate((a1, a2, ...), axis=0, out=None, dtype=None, casting="same_kind")`

- `a1, a2, ...`: `sequence of array_like` The arrays must have the same shape, except in the dimension corresponding to `axis`.
- `axis`: `int, optional` The axis along which the arrays will be joined. If `axis` is `None`, arrays are flattened before use. Default is `0`.
- `out`: `ndarray`, `optional` If provided, the destination to place the result. The shape must be correct.
- `dtype`: `str` or `dtype`, `optional` If provided, the destination array will have this `dtype`.
- `casting`: `{'no', 'equiv', 'safe', 'same_kind', 'unsafe'}`, `optional` Controls what kind of data casting may occur. Defaults to 'same_kind'.

```python
import numpy as np

# Concatenate 2 dim array
a = np.ones((2, 3))
b = np.zeros((2, 3))

# Concatenate along axis 0 (stacking rows)
print("Concatenate of a&b by axis 0")
print(np.concatenate((a, b), axis=0), end='\n\n')

# Concatenate along axis 1 (joining columns)
print("Concatenate of a&b by axis 1")
print(np.concatenate((a, b), axis=1))
```
```python
Concatenate of a&b by axis 0
[[1. 1. 1.]
 [1. 1. 1.]
 [0. 0. 0.]
 [0. 0. 0.]]

Concatenate of a&b by axis 1
[[1. 1. 1. 0. 0. 0.]
 [1. 1. 1. 0. 0. 0.]]
```

```python
import numpy as np

# Concatenate 3 dim array
a = np.ones((2, 2, 3))
b = np.zeros((2, 2, 3))

print("Concatenate of a&b by axis 0")
print(np.concatenate((a, b), axis=0), end='\n\n')

print("Concatenate of a&b by axis 1")
print(np.concatenate((a, b), axis=1), end='\n\n')

print("Concatenate of a&b by axis 2")
print(np.concatenate((a, b), axis=2))
```
```python
Concatenate of a&b by axis 0
[[[1. 1. 1.]
  [1. 1. 1.]]

 [[1. 1. 1.]
  [1. 1. 1.]]

 [[0. 0. 0.]
  [0. 0. 0.]]

 [[0. 0. 0.]
  [0. 0. 0.]]]


Concatenate of a&b by axis 1
[[[1. 1. 1.]
  [1. 1. 1.]
  [0. 0. 0.]
  [0. 0. 0.]]

 [[1. 1. 1.]
  [1. 1. 1.]
  [0. 0. 0.]
  [0. 0. 0.]]]


Concatenate of a&b by axis 2
[[[1. 1. 1. 0. 0. 0.]
  [1. 1. 1. 0. 0. 0.]]

 [[1. 1. 1. 0. 0. 0.]
  [1. 1. 1. 0. 0. 0.]]]
```
{% include end-box.html %}

**NumPy Stacking Functions**<br>
NumPy provides convenient functions, vstack and hstack, for stacking arrays vertically and horizontally, respectively. These are essentially shortcuts for using numpy.concatenate along specific axes.
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**`vstack()`**<br>
Stack arrays in sequence **vertically** (row-wise). This is equivalent to concatenation along the **first axis** (axis=0).

`numpy.vstack(tup, dtype=None, casting='same_kind')`

- `tup`: `sequence of ndarrays`
    :The arrays to stack. They must have the same shape along all but the first axis.

- `dtype`: `str` or `dtype`
    :If provided, the destination array will have this `dtype`.

- `casting`: `{'no', 'equiv', 'safe', 'same_kind', 'unsafe'}`, `optional`
    :Controls what kind of data casting may occur. Defaults to `'same_kind'`.

```python
import numpy as np

# vstack of 2 dim array
a = np.ones((2, 3))
b = np.zeros((2, 3))

print("vstack of a&b")
print("shape:", np.vstack((a, b)).shape)
print(np.vstack((a, b)), end='\n\n')

# Equivalent concatenate operation
print("concatenate of a&b by axis = 0")
print("shape:", np.concatenate((a, b), axis=0).shape)
print(np.concatenate((a, b), axis=0))
```
```python
vstack of a&b
shape: (4, 3)
[[1. 1. 1.]
 [1. 1. 1.]
 [0. 0. 0.]
 [0. 0. 0.]]

concatenate of a&b by axis = 0
shape: (4, 3)
[[1. 1. 1.]
 [1. 1. 1.]
 [0. 0. 0.]
 [0. 0. 0.]]
```

```python
# vstack of 3 dim array
a = np.ones((2, 2, 3))
b = np.zeros((2, 2, 3))

print("vstack of a&b")
print("shape:", np.vstack((a, b)).shape)
print(np.vstack((a, b)), end='\n\n')

# Equivalent concatenate operation
print("concatenate of a&b by axis = 0") # Corrected from axis=1 in image
print("shape:", np.concatenate((a, b), axis=0).shape)
print(np.concatenate((a, b), axis=0))
```
```python
vstack of a&b
shape: (4, 2, 3)
[[[1. 1. 1.]
  [1. 1. 1.]]

 [[1. 1. 1.]
  [1. 1. 1.]]

 [[0. 0. 0.]
  [0. 0. 0.]]

 [[0. 0. 0.]
  [0. 0. 0.]]]

concatenate of a&b by axis = 0
shape: (4, 2, 3)
[[[1. 1. 1.]
  [1. 1. 1.]]

 [[1. 1. 1.]
  [1. 1. 1.]]

 [[0. 0. 0.]
  [0. 0. 0.]]

 [[0. 0. 0.]
  [0. 0. 0.]]]
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**`hstack()`**<br>
Stack arrays in sequence **horizontally** (column-wise). This is equivalent to concatenation along the **second axis** (`axis=1`).

`numpy.hstack(tup, dtype=None, casting='same_kind')`

- `tup`: `sequence of ndarrays`
    :The arrays to stack. They must have the same shape along all but the second axis.
- `dtype`: `str` or `dtype`
    :If provided, the destination array will have this `dtype`.
- `casting`: `{'no', 'equiv', 'safe', 'same_kind', 'unsafe'}`, `optional`
    :Controls what kind of data casting may occur. Defaults to `'same_kind'`.

```python
# hstack of 2 dim array
a = np.ones((2, 3))
b = np.zeros((2, 3))

print("hstack of a&b")
print("shape:", np.hstack((a, b)).shape)
print(np.hstack((a, b)), end='\n\n')

# Equivalent concatenate operation
print("concatenate of a&b by axis = 1")
print("shape:", np.concatenate((a, b), axis=1).shape)
print(np.concatenate((a, b), axis=1))
```
```python
hstack of a&b
shape: (2, 6)
[[1. 1. 1. 0. 0. 0.]
 [1. 1. 1. 0. 0. 0.]]

concatenate of a&b by axis = 1
shape: (2, 6)
[[1. 1. 1. 0. 0. 0.]
 [1. 1. 1. 0. 0. 0.]]
```

```python
# hstack of 3 dim array
a = np.ones((2, 2, 3))
b = np.zeros((2, 2, 3))

print("hstack of a&b")
print("shape:", np.hstack((a, b)).shape)
print(np.hstack((a, b)), end='\n\n')

# Equivalent concatenate operation
print("concatenate of a&b by axis = 1")
print("shape:", np.concatenate((a, b), axis=1).shape)
print(np.concatenate((a, b), axis=1))
```
```python
hstack of a&b
shape: (2, 4, 3)
[[[1. 1. 1.]
  [1. 1. 1.]
  [0. 0. 0.]
  [0. 0. 0.]]

 [[1. 1. 1.]
  [1. 1. 1.]
  [0. 0. 0.]
  [0. 0. 0.]]]

concatenate of a&b by axis = 1
shape: (2, 4, 3)
[[[1. 1. 1.]
  [1. 1. 1.]
  [0. 0. 0.]
  [0. 0. 0.]]

 [[1. 1. 1.]
  [1. 1. 1.]
  [0. 0. 0.]
  [0. 0. 0.]]]
```
{% include end-box.html %}

{% include end-box.html %}

# 3. Array Operations
{% include start-box.html class="math-box"%}

## 3-1) Broadcasting
{% include start-box.html class="math-box"%}
In NumPy, operations are performed element-wise. 
This means that to perform an operation, the number of elements in the arrays must match.

However, in cases where the number of elements (`size`) or the number of dimensions (`ndim`) are different, NumPy can still perform the operation by following a set of **Broadcasting Rules**.

**[Broadcasting Rules]**
1. If the two arrays have a different number of dimensions, prepend `1`s to the `shape` of the array with fewer dimensions until they match.
2. In any dimension where the two arrays' shapes do not match, if one of them has a size of `1`, "stretch" (or tile) it to match the size of the other array.
3. If, after applying rules 1 & 2, there is any dimension where the sizes are different and neither is `1`, an error occurs.

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Case: Arrays with the Same Shape (No Broadcasting)**<br>
You can see element-wise operations being performed on all 9 elements of arrays `a` and `b`, which both have the shape (3, 3).
```python
import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
b = np.array([[10, 11, 12], [13, 14, 15], [16, 17, 18]])

print("Array a")
print(a, end='\n\n')

print("Array b")
print(b, end='\n\n')

print("a+b")
print(a + b, end='\n\n')

print("a-b")
print(a - b, end='\n\n')

print("a*b")
print(a * b, end='\n\n')

print("a/b")
print(a / b, end='\n\n')
```
```python
Array a
[[1 2 3]
 [4 5 6]
 [7 8 9]]

Array b
[[10 11 12]
 [13 14 15]
 [16 17 18]]

a+b
[[11 13 15]
 [17 19 21]
 [23 25 27]]

a-b
[[-9 -9 -9]
 [-9 -9 -9]
 [-9 -9 -9]]

a*b
[[ 10  22  36]
 [ 52  70  90]
 [112 136 162]]

a/b
[[0.1        0.18181818 0.25      ]
 [0.30769231 0.35714286 0.4       ]
 [0.4375     0.47058824 0.5       ]]
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Case: Arrays with Different Shapes (Broadcasting Occurs)**<br>
Ex.1: Successful Broadcasting (2D and 1D)
```python
# a.shape = (2, 3)
# ndim = 2
a = np.ones((2, 3))

# b.shape = (3, )
# ndim = 1
b = np.arange(1, 4, 1) # [1, 2, 3]

print("Array a")
print(a, end='\n\n')

print("Array b")
print(b, end='\n\n')

# Rule 1: To match ndim, b's shape (3,) becomes (1, 3).
# Rule 2: b's shape (1, 3) is compared to a's (2, 3). The first
#         dimension (axis 0) is 1, so it is stretched to 2.
print("Array b after broadcasting")
print(a + b) # Temporary broadcasted 'b' is [[1, 2, 3], [1, 2, 3]]
print("shape:", (a + b).shape)
print("ndim:", (a + b).ndim, end='\n\n')

print("a+b")
print(a + b, end='\n\n')

print("a-b")
print(a - b, end='\n\n')

print("a*b")
print(a * b, end='\n\n')

print("a/b")
print(a / b, end='\n\n')
```
```python
Array a
[[1. 1. 1.]
 [1. 1. 1.]]

Array b
[1 2 3]

Array b after broadcasting
[[2. 3. 4.]
 [2. 3. 4.]]
shape: (2, 3)
ndim: 2

a+b
[[2. 3. 4.]
 [2. 3. 4.]]

a-b
[[ 0. -1. -2.]
 [ 0. -1. -2.]]

a*b
[[1. 2. 3.]
 [1. 2. 3.]]

a/b
[[1.         0.5        0.33333333]
 [1.         0.5        0.33333333]]
```

Ex.2: Failed Broadcasting (Incompatible Shapes)
```python
# a.shape = (3, 3)
# ndim = 2
a = np.ones((3, 3))

# b.shape = (3, 2)
# ndim = 2
b = np.array([[1, 2], [3, 4], [5, 6]])

print("Array a")
print(a, end='\n\n')

print("Array b")
print(b, end='\n\n')

# Rule 1: Dims are equal (2), rule is skipped.
# Rule 2: Comparing shapes (3, 3) and (3, 2).
#         - Axis 0: 3 and 3 match. OK.
#         - Axis 1: 3 and 2 do not match, and NEITHER is 1.
# Rule 3: An error occurs.
print("Array b after broadcasting")
# The following line will raise an error
# print(a + b)
```
```python
Array a
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]

Array b
[[1 2]
 [3 4]
 [5 6]]

Array b after broadcasting
...
ValueError: operands could not be broadcast together with shapes (3,3) (3,2)
```

Ex.3: Failed Broadcasting (This example demonstrates a case where broadcasting fails due to incompatible shapes.)
```python
import numpy as np

# a = [[1, 1, 1], [1, 1, 1]]
# shape = (2, 3)
# ndim = 2
a = np.ones((2, 3))

# b = [1, 2]
# shape = (2, )
# ndim = 1
b = np.arange(1, 3, 1)

print("Array a")
print(a, end='\n\n')

print("Array b")
print(b, end='\n\n')

print("Array b after broadcasting")

# --- The Code Below This Line Will Cause an Error ---

# According to Broadcasting Rule 1, to match the dimensions of 2D array a,
# 1D array b's shape (2,) becomes (1, 2), and its ndim becomes 2. -> b = [[1, 2]]
# According to Broadcasting Rule 2, array b, now with shape (1, 2), is
# stretched... (This analysis is interrupted by the error)

# print((a + b))
# print("shape:", ((a + b)).shape)
# print("ndim:", ((a + b)).ndim, end='\n\n')
```
```python
Array a
[[1. 1. 1.]
 [1. 1. 1.]]

Array b
[1 2]

Array b after broadcasting

---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
...
ValueError: operands could not be broadcast together with shapes (2,3) (2,)
```
{% include end-box.html %}
{% include end-box.html %}

## 3-2) Array Arithmetic Operations
{% include start-box.html class="math-box"%}
As introduced earlier, operations between arrays are applied element-wise.

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`+` Operation
```python
import numpy as np

# Case: No broadcasting
a = np.array([[1, 2, 3], [4, 5, 6]])
b = np.ones((2, 3))
print(a + b)
```
```python
[[2. 3. 4.]
 [5. 6. 7.]]
```

<br>

```python
import numpy as np

# Case: Broadcasting occurs
a = np.array([[1, 2, 3], [4, 5, 6]])
b = np.ones((2, 1))
print(a + b)
```
```python
[[2. 3. 4.]
 [5. 6. 7.]]
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`-` Operation
```python
import numpy as np

# Case: No broadcasting
a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
b = np.ones((3, 3))
print(a - b)
```
```python
[[0. 1. 2.]
 [3. 4. 5.]
 [6. 7. 8.]]
```

<br>

```python
import numpy as np

# Case: Broadcasting occurs
a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
b = np.ones((3, 1))
print(a - b)
```
```python
[[0. 1. 2.]
 [3. 4. 5.]
 [6. 7. 8.]]
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`*` Operation
```python
import numpy as np

# Case: No broadcasting
a = np.array([[1, 2], [4, 5], [7, 8]])
b = np.full((3, 2), 2)
print(a * b)
```
```python
[[ 2  4]
 [ 8 10]
 [14 16]]
```

<br>

```python
import numpy as np

# Case: Broadcasting occurs
a = np.array([[1, 2], [4, 5], [7, 8]])
b = np.full((3, 1), 2)
print(a * b)
```
```python
[[ 2  4]
 [ 8 10]
 [14 16]]
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`/` and `//` Operations
```python
import numpy as np

# Case: No broadcasting
a = np.array([[1, 2], [4, 5], [7, 8]])
b = np.full((3, 2), 2)
print(a / b)
print(a // b)
```
```python
[[0.5 1. ]
 [2.  2.5]
 [3.5 4. ]]
[[0 1]
 [2 2]
 [3 4]]
```

<br>

```python
import numpy as np

# Case: Broadcasting occurs
a = np.array([[1, 2], [4, 5], [7, 8]])
b = np.full((3, 1), 2)
print(a / b)
print(a // b)
```
```python
[[0.5 1. ]
 [2.  2.5]
 [3.5 4. ]]
[[0 1]
 [2 2]
 [3 4]]
```
{% include end-box.html %}
{% include end-box.html %}

## 3-3) Array Linear Algebra
{% include start-box.html class="math-box"%}
NumPy arrays fundamentally perform element-wise operations, which is different from standard linear algebra operations.

Therefore, you must use special functions for linear algebra operations. 
These include the array's `dot()` method and various functions in the `numpy.linalg` module.

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Array Dot Product (`dot()`)**<br>
In NumPy, the `*` operator performs element-wise multiplication, not the matrix multiplication from linear algebra. 
Therefore, to perform a dot product (matrix multiplication) as in linear algebra, you must use the `dot()` function.

For arrays `a` and `b`, `dot()` can be used as follows:
- `a.dot(b)`
- `np.dot(a, b)`

Example 1: 2D Array Dot Product (Method)
```python
import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
b = np.array([[3, 5], [5, 7], [7, 9]])

print(a.dot(b))
```
```python
[[ 34  46]
 [ 79 109]
 [124 172]]
```

Example 2: 2D Array Dot Product (Function)
```python
a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
b = np.array([[3], [5], [7]])

print(np.dot(a, b))
```
```python
[[ 34]
 [ 79]
 [124]]
```

Example 3: 3D Array Dot Product
```python
# A 3D array with shape (3, 2, 2)
a = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]], [[9, 10], [11, 12]]])
b = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]], [[9, 10], [11, 12]]])

print(np.dot(a,b), end='\n\n')
print(np.dot(a,b).shape, end='\n\n')
print(np.dot(a,b).ndim)
```
```python
[[[[  7  10]
   [ 19  22]
   [ 31  34]]

  [[ 15  22]
   [ 43  50]
   [ 71  78]]]


 [[[ 23  34]
   [ 67  78]
   [111 122]]

  [[ 31  46]
   [ 91 106]
   [151 166]]]


 [[[ 39  58]
   [115 134]
   [191 210]]

  [[ 47  70]
   [139 162]
   [231 254]]]]

(3, 2, 3, 2)

4
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
numpy.linalg
```python

```
```python

```
{% include end-box.html %}

{% include end-box.html %}


{% include end-box.html %}