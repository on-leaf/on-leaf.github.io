---
layout: single
title:  "8.Dictionary"
category: "Python"
tag: [Python]
header:
  teaser: #../images/2025-07-08-CT_6/image-20250708184503610.png
toc: true
toc_sticky: true
toc_label: CONTENTS
toc_icon: "fa-solid fa-seedling" # More icons: https://fontawesome.com/v6/search?ic=free
author_profile: false
sidebar:
    nav: "counts"
search: true # Change true to false if you don't want to have this article be searched 
redirect_from:
    - /Python/Python_8
use_math: true
---

**[Reference]** <br>
$\bullet$ [홍정모의 파이썬 프로그래밍 추월코스](https://www.honglab.ai/courses/python)<br>
This post is written based on above lecture.<br>
All contents in this post are not the same with above lecture.<br>
Please show the detail at the his lecture.
{: .notice--success}

# 0.Introduction
{% include start-box.html class="math-box"%}
The data types we've discussed so far have been sequences, where items are arranged in a specific order. 
The dictionary (`dict`) data type is different; it's a form where data is stored and used as **key**-**value** pairs.

Just as `list` and `tuple` are classified as sequence types, dictionaries are classified as a **_mapping_** data type. 
Here, "mapping" refers to the broad mathematical concept of an association between a key and its related value. 

Similar to `set`, dictionaries do not allow duplicate keys.
{% include end-box.html %}

# 1.Dictionary
{% include start-box.html class="math-box"%}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
We use `{}` and `,` to mask `dict`. 
Inside the braces, a key and a value are paired together using a colon `:`.
```python
# Empty dict
d_1 = {}
d_2 = dict()

# Dict with keys and values
d_3 = {
    "White" : "banana",
    "Blue" : "apple",
    10 : 2, # The trailing comma is ignored. It's convenient to leave it if you frequently add new items.
}

print(d_1, d_2, d_3)
print(type(d_1), type(d_2), type(d_3))
```
```python
{} {} {'White': 'banana', 'Blue': 'apple', 10: 2}
<class 'dict'> <class 'dict'> <class 'dict'>
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
Same `dict` can be created in various style.
```python
# All same dict
d1 = {"one": 1, "two": 2, "three": 3}
d2 = dict({"three": 3, "one": 1, "two": 2})
d3 = dict({"one": 1, "three": 3}, two=2)
d4 = dict(one=1, two=2, three=3)
d5 = dict([("two", 2), ("one", 1), ("three", 3)]) # list of tuple

print(d1); print(d2); print(d3); print(d4); print(d5)
```
```python
{'one': 1, 'two': 2, 'three': 3}
{'three': 3, 'one': 1, 'two': 2}
{'one': 1, 'three': 3, 'two': 2}
{'one': 1, 'two': 2, 'three': 3}
{'two': 2, 'one': 1, 'three': 3}
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`zip()`: Takes items sequentially from two different iterables and pairs them together into tuples.
If we convert the result of zip() to a list, you will get a list of these tuples.
```python
d = dict(zip(["White", "Blue", "Red"], ["mandarin", "apple", "banana"]))

print(d)
```
```python
{'White': 'mandarin', 'Blue': 'apple', 'Red': 'banana'}
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
If there are duplicate keys, only the last value will be kept. (Duplication of value is ok) 
This is similar to how a `set` does not allow duplicate items.
```python
d = dict(zip(["White", "White", "Red"], ["mandarin", "apple", "banana"]))

print(d)
```
```python
{'White': 'apple', 'Red': 'banana'}
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
Only immutable objects can be used as dictionary keys. 
This is because if a key were to change, it would become impossible to find.
```python
d = {("tuple1", "tuple2") : 1002, (10, 11) : "numbers"}

print(d)
```
```python
{('tuple1', 'tuple2'): 1002, (10, 11): 'numbers'}
```
<br>
`list` key makes error.
```python
d = {("tuple1", "tuple2") : 1002, [10, 11] : "numbers"}

print(d)
```
```python
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Cell In[9], line 1
----> 1 d = {("tuple1", "tuple2") : 1002, [10, 11] : "numbers"}
      3 print(d)

TypeError: unhashable type: 'list'
```
<br>
`list` used for values is possible.
```python
d = {("tuple1", "tuple2") : 1002, "numbers" : [10, 11]}

print(d)
```
```python
{('tuple1', 'tuple2'): 1002, 'numbers': [10, 11]}
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
Using `float` as keys is not recommended. 
This is because a dictionary treats an `int` and a `float` as the same key if they have the same value (e.g., 10 and 10.0).
```python
d = {10 : "Ten", 10.0 : "TEN"}

d
```
```python
{10: 'TEN'}
```
{% include end-box.html %}

{% include end-box.html %}

# 2.How to use dictionary
{% include start-box.html class="math-box"%}
## 2-1) How to find a balue using a key
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
We can find a value by placing its corresponding key inside `[]`.
```python
d = {("tuple1", "tuple2") : 1002, "numbers" : [10, 11]}

print(d[("tuple1", "tuple2")])
```
```python
1002
```
{% include end-box.html %}

## 2-2) Method of dictionary
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`dict.get()`: Return the value if the key exists. However, if the key does not exist, it returns `None` instead of raising a KeyError.
```python
d = {'White': 'mandarin', 'Blue': 'apple', 'Red': 'banana'}

print(d.get("Red"), d.get("Yellow"))
```
```python
banana None
```
<br>
We can set a default value to be returned if the key does not exist.
```python
d = {'White': 'mandarin', 'Blue': 'apple', 'Red': 'banana'}

print(d.get("Red"), d.get("Yellow", "No color"))
```
```python
banana No color
```
<br>
We can also use membership operators to avoid errors. (The membership operator `in` is applied to the keys of a dictionary.)
```python
d = {'White': 'mandarin', 'Blue': 'apple', 'Red': 'banana'}

if "Yellow" in d:
    print("The value is", d["Yellow"])
else:
    print("No color")
```
```python
No color
```
{% include end-box.html %}

## 2-3) Adding/Changing key-value pairs
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
We can add a new key-value pair for a key that doesn't already exist, and the insertion order will be preserved.
```python
d = {'White': 'mandarin', 'Blue': 'apple', 'Red': 'banana'}

d["Yellow"] = "grape"

d
```
```python
{'White': 'mandarin', 'Blue': 'apple', 'Red': 'banana', 'Yellow': 'grape'}
```
<br>
An `int` value can be modified (e.g., incremented), and it can also be replaced entirely with an object of a different data type.
```python
d = {'White': 'mandarin', 'Blue': 10, 6: 'banana'}
print(d)

# If the value is an integer, you can increment it.
d['Blue'] += 1
print(d)

# We can replace the value with a different object entirely.
d['Blue'] = "sky"
print(d)
```
```python
{'White': 'mandarin', 'Blue': 10, 6: 'banana'}
{'White': 'mandarin', 'Blue': 11, 6: 'banana'}
{'White': 'mandarin', 'Blue': 'sky', 6: 'banana'}
```
<br>
If a dictionary's value is a sequence (like a `list`, `tuple`, or `str`), we can index and slice it.
```python
d = {"numbers":[x for x in range(0,11)]}

print(d); print(d["numbers"][0:6])

range(0,11)
```
```python
{'numbers': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}
[0, 1, 2, 3, 4, 5]
```
{% include end-box.html %}

## 2-4) Keyword and method of dictionary
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`dict.append()`
```python
d = {"fruits":["apple", "banana"]}
d["fruits"].append("mandarin")

print(d)
```
```python
{'fruits': ['apple', 'banana', 'mandarin']}
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`dict.reverse()`
```python
d = {"fruits":["apple", "banana", "mandarin"]}
d["fruits"].reverse()

print(d)
```
```python
{'fruits': ['mandarin', 'banana', 'apple']}
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
We can use a `dict` as a value inside another `dict`.
```python
d = {"key1":{"key2":{"key3":"value"}}}

d["key1"]["key2"]["key3"]
```
```python
'value'
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
We can use the `del` keyword to delete a key-value pair. 
Unlike `.pop()`, `del` does not return the deleted value; it simply removes the pair from the dictionary.
```python
d = {'White': 'mandarin', 'Blue': 'apple', 'Red': 'banana'}
del d["White"]

print(d)
```
```python
{'Blue': 'apple', 'Red': 'banana'}
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`dict.pop()`<br>
We can also use the `.pop()` method. 
Unlike with a `list`, you must provide a key, not an index.
```python
d = {'White': 'mandarin', 'Blue': 'apple', 'Red': 'banana'}

print(d.pop("White")); print(d)
```
```python
mandarin
{'Blue': 'apple', 'Red': 'banana'}
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`dict.clear()`
```python
import sys

d = {'White': 'mandarin', 'Blue': 'apple', 'Red': 'banana'}
print(d, sys.getsizeof(d))

d.clear()
print(d, sys.getsizeof(d))
```
```python
{'White': 'mandarin', 'Blue': 'apple', 'Red': 'banana'} 232
{} 64
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`dict.len()`, `in`<br>
For dictionaries, the `len()` function and the `in` operator also operate based on the keys.
```python
d = {'White': 'mandarin', 'Blue': 'apple', 'Red': 'banana'}

print(len(d))
print('Blue' in d)
```
```python
3
True
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`dict.keys()` and `dict.values()`<br>
We can use the `dict.keys()` and `dict.values()` methods to create collections of a dictionary's keys and values, respectively.
```python
d = {'White': 'mandarin', 'Blue': 'apple', 'Red': 'banana'}

print(d.keys())
print(d.values())

print(list(d.keys()))
print(list(d.values()))
```
```python
dict_keys(['White', 'Blue', 'Red'])
dict_values(['mandarin', 'apple', 'banana'])
['White', 'Blue', 'Red']
['mandarin', 'apple', 'banana']
```
<br>
If you `zip()` the list of keys and the list of values together, we can reconstruct the original dict.
```python
d = {'White': 'mandarin', 'Blue': 'apple', 'Red': 'banana'}
print(d, type(d))

key_list = list(d.keys())
val_list = list(d.values())

print(key_list, type(key_list))
print(val_list, type(val_list))

zip_key_val = zip(key_list, val_list)

print(zip_key_val, type(zip_key_val))

d_zip = dict(zip_key_val)

print(d_zip, type(d_zip))
```
```python
{'White': 'mandarin', 'Blue': 'apple', 'Red': 'banana'} <class 'dict'>
['White', 'Blue', 'Red'] <class 'list'>
['mandarin', 'apple', 'banana'] <class 'list'>
<zip object at 0x00000277F2829180> <class 'zip'>
{'White': 'mandarin', 'Blue': 'apple', 'Red': 'banana'} <class 'dict'>
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`dict.items()`<br>
We can use the `dict.items()` method to get a collection of a dictionary's (key, value) tuple pairs.
```python
d = {'White': 'mandarin', 'Blue': 'apple', 'Red': 'banana'}

key_val_item = d.items()
print(key_val_item, type(key_val_item))

key_val_item_list = list(key_val_item)
print(key_val_item_list, type(key_val_item_list))
```
```python
dict_items([('White', 'mandarin'), ('Blue', 'apple'), ('Red', 'banana')]) <class 'dict_items'>
[('White', 'mandarin'), ('Blue', 'apple'), ('Red', 'banana')] <class 'list'>
```
<br>
```python
d = {'White': 'mandarin', 'Blue': 'apple', 'Red': 'banana'}

key_val_item = d.items()
print(key_val_item, type(key_val_item))

for key_val in key_val_item:
    print(key_val, type(key_val))
```
```python
dict_items([('White', 'mandarin'), ('Blue', 'apple'), ('Red', 'banana')]) <class 'dict_items'>
('White', 'mandarin') <class 'tuple'>
('Blue', 'apple') <class 'tuple'>
('Red', 'banana') <class 'tuple'>
```
<br>
```python
d = {'White': 'mandarin', 'Blue': 'apple', 'Red': 'banana'}

key_val_item = d.items()
print(key_val_item, type(key_val_item))

key_val_item_list = list(key_val_item)
print(key_val_item_list, type(key_val_item_list))

for key_val in key_val_item_list:
    print(key_val, type(key_val))
```
```python
dict_items([('White', 'mandarin'), ('Blue', 'apple'), ('Red', 'banana')]) <class 'dict_items'>
[('White', 'mandarin'), ('Blue', 'apple'), ('Red', 'banana')] <class 'list'>
('White', 'mandarin') <class 'tuple'>
('Blue', 'apple') <class 'tuple'>
('Red', 'banana') <class 'tuple'>
```
<br>
```python
d = {'White': 'mandarin', 'Blue': 'apple', 'Red': 'banana'}

key_val_item = d.items()
print(key_val_item, type(key_val_item))

for key, val in key_val_item:
    print(key, val, type(key), type(val))
```
```python
dict_items([('White', 'mandarin'), ('Blue', 'apple'), ('Red', 'banana')]) <class 'dict_items'>
White mandarin <class 'str'> <class 'str'>
Blue apple <class 'str'> <class 'str'>
Red banana <class 'str'> <class 'str'>
```
<br>
```python
d = {'White': 'mandarin', 'Blue': 'apple', 'Red': 'banana'}

key_val_item = d.items()
print(key_val_item, type(key_val_item))

key_val_item_list = list(key_val_item)
print(key_val_item_list, type(key_val_item_list))

for key, val in key_val_item_list:
    print(key, val, type(key), type(val))
```
```python
dict_items([('White', 'mandarin'), ('Blue', 'apple'), ('Red', 'banana')]) <class 'dict_items'>
[('White', 'mandarin'), ('Blue', 'apple'), ('Red', 'banana')] <class 'list'>
White mandarin <class 'str'> <class 'str'>
Blue apple <class 'str'> <class 'str'>
Red banana <class 'str'> <class 'str'>
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`sorted()`<br>
When we pass a dictionary to the `sorted()` function, it sorts the dictionary's keys and returns them as a new list.
```python
d = {'White': 'mandarin', 'Blue': 'apple', 'Red': 'banana'}

d_sorted = sorted(d)

print(d_sorted, type(d_sorted))
```
```python
['Blue', 'Red', 'White'] <class 'list'>
```
{% include end-box.html %}
{% include end-box.html %}