---
layout: single
title:  "11.Function"
category: "Python"
tag: [Python]
header:
  teaser: #../images/2025-07-08-CT_6/image-20250708184503610.png
toc: true
toc_sticky: true
toc_label: CONTENTS
toc_icon: "fa-solid fa-seedling" # More icons: https://fontawesome.com/v6/search?ic=free
author_profile: false
sidebar:
    nav: "counts"
search: true # Change true to false if you don't want to have this article be searched 
redirect_from:
    - /Python/Python_9
use_math: true
---

**[Reference]** <br>
$\bullet$ [홍정모의 파이썬 프로그래밍 추월코스](https://www.honglab.ai/courses/python)<br>
This post is written based on above lecture.<br>
All contents in this post are not the same with above lecture.<br>
Please show the detail at the his lecture.
{: .notice--success}

# Introduction
In English, the word "function" refers to a purpose or capability. 
In computer programming, a function is a named block of statements grouped together to perform a specific task.

Until now, we have studied from the perspective of how to use the various functions that are either built-in to Python or provided by packages. 
From now on, let's gradually shift our perspective towards creating various functions ourselves and combining them to build progressively larger and more complex programs.

The syntax for functions is not difficult, as it's primarily designed for the programmer's convenience. 

If you develop the skill to first grasp the input-output relationship of each function from an abstract viewpoint to unravel the overall structure, you won't be intimidated when building large and complex programs.

`Input -> Function -> Output`

After we review the useful concepts and syntax related to functions, in the following sections we will learn how to properly utilize them one by one as we build various programs.

# 1.Function
{% include start-box.html class="math-box"%}
## 1-1) Process to make `function`
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
1. Consider how to break down the overall program.
2. Define the input and output for each individual function.
3. Implement the function according to the syntax.
{% include end-box.html %}

## 1-2) Format of `function`
The basic syntax for a function is as follows:
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
```python
def function_name(parameter1, parameter2, ...):
    """You can add a description of the function's purpose here."""
    
    # Statements that perform a task or calculate a return value
    
    return return_value # or an expression that calculates the return value
```
- When creating a function, you use the `def` keyword, which stands for "define."
- In Python, function names are conventionally written in snake_case.
- Inside the parentheses `()`, you can list the parameters required for the `function` to perform its task. Even for a `function` with no parameters, the parentheses are still required.
- At the beginning of the `function` body, you can insert a description of the `function` between triple quotes (`"""`). This is called a `docstring` and is syntactically a multi-line string.
- The `return` statement ends the function's execution and sends a value back to the place where the function was called.
- If the expression to the right of `return` is omitted, or if the `return` statement itself is omitted, the function will implicitly return `None`.
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`function` example
```python
def add_two(a, b):
    # Inside the function body, `a` and `b` can be used like variables.
    
    temp = a + b
    
    return temp

result = add_two(1, 2)

print(result)
```
```python
3
```
When you call the function by passing 1 and 2 in the parameter positions, the function calculates temp as if 1 were assigned to a and 2 were assigned to b. 
When temp is returned, its value is sent back to the place where the `function` was called, and it is then assigned to the result variable.

a and b as used in the function definition are called parameters. 
The actual values, 1 and 2, that are passed into the function when it is called are called **_arguments_**.
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
We can also use expressions as arguments.

```python
def add_two(a, b):
    temp = a + b
    return temp

x = 1

# An argument passed as an expression
result = add_two(x + 100, 2) 

print(result)
```
```python
103
```
{% include end-box.html %}
{% include end-box.html %}

# 2.Parameters
{% include start-box.html class="math-box"%}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
When passing arguments to a function, we must match the number and order of the parameters defined in the function's signature.
```python
def repeat_print(message, count):
    """Prints the message 'count' number of times."""
    
    for _ in range(count):
        print(message)
        
repeat_print("Hello", 3)
```
```python
Hello
Hello
Hello
```
This method of passing arguments is called using **_positional arguments_** because you must exactly match the order of the arguments to the order of the parameters.
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
When passing arguments, we can ignore the order if you explicitly specify which parameter each argument should go to. 
This is called using **_keyword arguments_**.
```python
def repeat_print(message, count):
    """Prints the message 'count' number of times."""

    for _ in range(count):
        print(message)

# When using keyword arguments,
# no error occurs even if the order of the arguments
# is different from the defined order of the parameters.
repeat_print(count=3, message="Hello")
```
```python
Hello
Hello
Hello
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
We can also set default values for parameters. 
If an argument is not provided for a parameter that has a default value, Python will automatically use that default. 
This means you don't have to supply every argument for every function call.
```python
def repeat_print(message="Hi", count=1):
    """Prints the message 'count' number of times."""
    
    for _ in range(count):
        print(message)
    print() # For a newline

# Call with no arguments; both defaults are used.
repeat_print()

# Call with one positional argument; the default for 'count' is used.
repeat_print("Hello")

# Call with one keyword argument; the default for 'message' is used.
repeat_print(count=2)
```
```python
Hi

Hello

Hi
Hi
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
When using positional arguments, if you provide fewer arguments than the total number of parameters, the arguments are assigned to the parameters from left to right.
```python
# Order: message, count
def repeat_print(message="Hello", count=1):
    """Prints message count times"""
    for _ in range(count):
        print(message)

repeat_print(3)
```
```python
3
```
<br>
```python
# Order: count, message
def repeat_print(count=1, message="Hello"):
    """Prints message count times"""
    for _ in range(count):
        print(message)

repeat_print(3)
```
```python
Hello
Hello
Hello
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
We do not have to set a default value for every parameter, but parameters without default values must come before parameters with default values. 
It is standard practice to place required parameters (those that must always receive an argument) further to the left in the function definition.
```python
# 'message' (no default) comes before 'count' (has a default).
def repeat_print(message, count=1):
    """Prints the message 'count' number of times."""
    for _ in range(count):
        print(message)
```
{% include end-box.html %}

{% include end-box.html %}

# 3.Duck typing
{% include start-box.html class="math-box"%}
`"If it walks like a duck and it quacks like a duck, then it must be a duck."`

This phrase is often used to describe the nature of dynamic typing in Python.

In the context of function parameters, it means that the function doesn't care about the specific data type of an argument. As long as the argument can perform the actions required of it inside the function, it is considered valid.

This has the advantage of making Python programming very flexible and convenient. On the other hand, it has the disadvantage of making it difficult to prevent objects from being used in unintended ways.

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
The function works correctly as long as the object passed to message supports the `len()` function and slicing. However, an error will occur if an object of a data type that does not support these operations is provided.
```python
def print_triangle(message):
    for i in range(len(message) + 1):
        print(message[:i])

# Works with a string
print_triangle("Hello?")
print("-" * 20)

# Works with a list
print_triangle(["Apple", "Banana", "Mandarin"])
print("-" * 20)

# Causes an error with an integer
print_triangle(123)
```
```python
H
He
Hel
Hell
Hello
Hello?
--------------------
[]
['Apple']
['Apple', 'Banana']
['Apple', 'Banana', 'Mandarin']
--------------------
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Cell In[3], line 16
     13 print("-" * 20)
     15 # Causes an error with an integer
---> 16 print_triangle(123)

Cell In[3], line 3
      2 def print_triangle(message):
----> 3     for i in range(len(message) + 1):
      4         print(message[:i])

TypeError: object of type 'int' has no len()
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
It can be difficult to detect in advance when a function will operate differently from the user's intention.
```python
def repeat_print(message="Hello", count=1):
    """Prints the message 'count' number of times."""
    
    for _ in range(count):
        print(message)

repeat_print(3)
```
```python
3
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
To prevent a function from behaving differently than intended, we can supplement its definition with **_type hinting_**, a way to provide hints about the expected data types of parameters and return values.
```python
# Initialize parameters along with their data types in the function declaration.
def repeat_print(message: str = "Hello", count: int = 1) -> None: # '-> None' means the function returns None.
    """Prints the message 'count' number of times."""
    
    for _ in range(count):
        print(message)

# This call now works as intended, and a type checker would see it as valid.
repeat_print(count = 3)
```
```python
Hello
Hello
Hello
```
{% include end-box.html %}
{% include end-box.html %}

# 4.When the number of arguments can vary
{% include start-box.html class="math-box"%}
If you want to pass a varying number of arguments into a single parameter, the most straightforward method is to pass them inside a container (like a list or tuple). Arguments that can change in length like this are called **_variable-length arguments_**.

## 4-1) Tuple
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
Pass a single tuple as the argument.
```python
def print_many(my_tuple):
    print(my_tuple)

print_many((1, 2, 3, 4, 5))
```
```python
(1, 2, 3, 4, 5)
```
<br>
If we simply pass multiple arguments, an error will occur. This is because the number of arguments does not match the number of parameters.
```python
def print_many(my_tuple):
    print(my_tuple)

print_many(1, 2, 3, 4, 5)
```
```python
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Cell In[2], line 6
      1 def print_many(my_tuple):
      3     print(my_tuple)
----> 6 print_many(1, 2, 3, 4, 5) 

TypeError: print_many() takes 1 positional argument but 5 were given
```
<br>
If we prefix a parameter name with an asterisk (`*`), it will collect all the positional arguments into a `tuple`.
```python
def print_many(*arguments):
    print(type(arguments))
    print(arguments)

print_many(1, 2, 3, 4, 5)
```
```python
<class 'tuple'>
(1, 2, 3, 4, 5)
```
<br>
If you pass a single tuple to a parameter that uses *args, the result is a new tuple that contains the passed tuple as its single item.
```python
def print_many(*arguments):
    print(type(arguments))
    print(arguments)

# Here, ONE argument (a tuple) is passed to the function.
print_many((1, 2, 3, 4, 5))
```
```python
<class 'tuple'>
((1, 2, 3, 4, 5),)
```
{% include end-box.html %}

## 4-2) Dictionary
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
The traditional way to pass a `dictionary` as a single argument.
```python
def print_many(my_dict):
    print(type(my_dict))
    for k in my_dict:
        print(k, ":", my_dict[k])

print_many({"a": 65, "b": 66})
```
```python
<class 'dict'>
a : 65
b : 66
```
<br>
If you prefix a parameter name with a double asterisk (`**`), it will collect all the keyword arguments into a `dictionary`. It's important to note that you use an equals sign (`=`) for the arguments (not a colon `:`), and the keywords automatically become the `str` keys of the dictionary.
```python
def print_many(**keywords):
    print(type(keywords))
    for k in keywords:
        print(k, ":", keywords[k])

print_many(a = 65, b = 66)
```
```python
<class 'dict'>
a : 65
b : 66
```
<br>
Passing a dictionary literal directly to a parameter that uses the `**` syntax will cause an error.
```python
def print_many(**my_dict):
    print(type(my_dict))
    for k in my_dict:
        print(k, ":", my_dict[k])

print_many({"a":65, "b": 66})
```
```python
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Cell In[10], line 8
      4     for k in my_dict:
      5         print(k, ":", my_dict[k])
----> 8 print_many({"a":65, "b": 66})

TypeError: print_many() takes 0 positional arguments but 1 was given
```
{% include end-box.html %}
{% include end-box.html %}

# 5.Unpacking operator
{% include start-box.html class="math-box"%}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
Unpacking operator: `*`
```python
my_list = [1, 2, 3]

# Without unpacking, this prints the list object itself.
print(my_list)

# With unpacking, this passes the items as individual arguments.
print(*my_list)
```
```python
[1, 2, 3]
1 2 3
```
<br>
We can also use the `*` operator to unpack iterables into a new `list`. This is a powerful and readable way to combine or merge multiple lists.
```python
my_list1 = [1, 2, 3]
my_list2 = [4, 5, 6]

# Without unpacking, this creates a nested list (a list of lists).
my_list_nested = [my_list1, my_list2]
print(my_list_nested)

# With unpacking, this creates a single, flattened list.
my_list_flat = [*my_list1, *my_list2]
print(my_list_flat)
```
```python
[[1, 2, 3], [4, 5, 6]]
[1, 2, 3, 4, 5, 6]
```
<br>
We can also unpack a single `list` to provide multiple arguments to a function.
```python
def add_three(a, b, c):
    print("a =", a)
    print("b =", b)
    print("c =", c)
    return a + b + c

# The * operator unpacks the list into individual arguments.
# This call is equivalent to add_three(1, 2, 3)
add_three(*[1, 2, 3])
```
```python
a = 1
b = 2
c = 3
6
```
<br>
When you unpack a `dict` with the single asterisk (`*`) operator, only its `keys` are passed as arguments.
```python
def add_three(a, b, c):
    print("a =", a)
    print("b =", b)
    print("c =", c)
    return a + b + c

# Unpacking a dictionary with * passes its keys as positional arguments.
add_three(*{"A": 1, "B": 2, "C": 3})
```
```python
a = A
b = B
c = C
'ABC'
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
Unpacking operator: `**`<br>
If We want to unpack a `dict` so that its keys match the function's parameter names and its values are passed as arguments, we must use the double asterisk (`**`) operator.
```python
Dict = {**{"a": 1, "b": 2, "c":3}}
Dict
```
```python
{'a': 1, 'b': 2, 'c': 3}

```
<br>
```python
def add_three(a, b, c):
    return a + b + c

my_dict = {'a': 1, 'b': 2, 'c': 3}

# The ** operator unpacks the dictionary into keyword arguments.
result = add_three(**my_dict)

print(result) 
```
```python
6
```
<br>
```python
def add_three(a, b, c):

    print("a = ", a)
    print("b = ", b)
    print("c = ", c)

    return a + b + c

add_three(**{"a": 1, "b": 2, "c":3})
```
```python
a =  1
b =  2
c =  3

6
```
<br>
However, when you unpack a dictionary using `**`, the keys of the dictionary must match the parameter names in the function definition. If they don't, an error will occur.
```python
def add_three(a, b, c):

    print("a = ", a)
    print("b = ", b)
    print("c = ", c)

    return a + b + c

add_three(**{"i": 1, "j": 2, "k":3})
```
```python
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Cell In[35], line 10
      5     print("c = ", c)
      7     return a + b + c
---> 10 add_three(**{"i": 1, "j": 2, "k":3})

TypeError: add_three() got an unexpected keyword argument 'i'
```
<br>
```python
def add_three(i, j, k):

    print("i = ", i)
    print("j = ", j)
    print("k = ", k)

    return i + j + k

add_three(**{"i": 1, "j": 2, "k":3})
```
```python
i =  1
j =  2
k =  3

6
```
{% include end-box.html %}
{% include end-box.html %}
{% include end-box.html %}

# 6.Return
{% include start-box.html class="math-box"%}

{% include end-box.html %}











```python

```
```python

```



<div class="indented-paragraph" markdown="1">

</div>

{% include start-box.html class="math-box-inner" font_size="0.8em"%}

```python

```
```python

```
{% include end-box.html %}


{% include start-box.html class="math-box"%}

{% include end-box.html %}