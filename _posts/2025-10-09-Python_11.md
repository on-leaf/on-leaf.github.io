---
layout: single
title:  "11.Function"
category: "Python"
tag: [Python]
header:
  teaser: #../images/2025-07-08-CT_6/image-20250708184503610.png
toc: true
toc_sticky: true
toc_label: CONTENTS
toc_icon: "fa-solid fa-seedling" # More icons: https://fontawesome.com/v6/search?ic=free
author_profile: false
sidebar:
    nav: "counts"
search: true # Change true to false if you don't want to have this article be searched 
redirect_from:
    - /Python/Python_11
use_math: true
---

**[Reference]** <br>
$\bullet$ [홍정모의 파이썬 프로그래밍 추월코스](https://www.honglab.ai/courses/python)<br>
This post is written based on above lecture.<br>
All contents in this post are not the same with above lecture.<br>
Please show the detail at the his lecture.
{: .notice--success}

# Introduction
In English, the word "function" refers to a purpose or capability. 
In computer programming, a function is a named block of statements grouped together to perform a specific task.

Until now, we have studied from the perspective of how to use the various functions that are either built-in to Python or provided by packages. 
From now on, let's gradually shift our perspective towards creating various functions ourselves and combining them to build progressively larger and more complex programs.

The syntax for functions is not difficult, as it's primarily designed for the programmer's convenience. 

If you develop the skill to first grasp the input-output relationship of each function from an abstract viewpoint to unravel the overall structure, you won't be intimidated when building large and complex programs.

`Input -> Function -> Output`

After we review the useful concepts and syntax related to functions, in the following sections we will learn how to properly utilize them one by one as we build various programs.

# 1.Function
{% include start-box.html class="math-box"%}
## 1-1) Process to make `function`
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
1. Consider how to break down the overall program.
2. Define the input and output for each individual function.
3. Implement the function according to the syntax.
{% include end-box.html %}

## 1-2) Format of `function`
The basic syntax for a function is as follows:
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
```python
def function_name(parameter1, parameter2, ...):
    """You can add a description of the function's purpose here."""
    
    # Statements that perform a task or calculate a return value
    
    return return_value # or an expression that calculates the return value
```
- When creating a function, you use the `def` keyword, which stands for "define."
- In Python, function names are conventionally written in snake_case.
- Inside the parentheses `()`, you can list the parameters required for the `function` to perform its task. Even for a `function` with no parameters, the parentheses are still required.
- At the beginning of the `function` body, you can insert a description of the `function` between triple quotes (`"""`). This is called a `docstring` and is syntactically a multi-line string.
- The `return` statement ends the function's execution and sends a value back to the place where the function was called.
- If the expression to the right of `return` is omitted, or if the `return` statement itself is omitted, the function will implicitly return `None`.
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`function` example
```python
def add_two(a, b):
    # Inside the function body, `a` and `b` can be used like variables.
    
    temp = a + b
    
    return temp

result = add_two(1, 2)

print(result)
```
```python
3
```
When you call the function by passing 1 and 2 in the parameter positions, the function calculates temp as if 1 were assigned to a and 2 were assigned to b. 
When temp is returned, its value is sent back to the place where the `function` was called, and it is then assigned to the result variable.

a and b as used in the function definition are called parameters. 
The actual values, 1 and 2, that are passed into the function when it is called are called **_arguments_**.
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
We can also use expressions as arguments.

```python
def add_two(a, b):
    temp = a + b
    return temp

x = 1

# An argument passed as an expression
result = add_two(x + 100, 2) 

print(result)
```
```python
103
```
{% include end-box.html %}
{% include end-box.html %}

# 2.Parameters
{% include start-box.html class="math-box"%}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
When passing arguments to a function, we must match the number and order of the parameters defined in the function's signature.
```python
def repeat_print(message, count):
    """Prints the message 'count' number of times."""
    
    for _ in range(count):
        print(message)
        
repeat_print("Hello", 3)
```
```python
Hello
Hello
Hello
```
This method of passing arguments is called using **_positional arguments_** because you must exactly match the order of the arguments to the order of the parameters.
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
When passing arguments, we can ignore the order if you explicitly specify which parameter each argument should go to. 
This is called using **_keyword arguments_**.
```python
def repeat_print(message, count):
    """Prints the message 'count' number of times."""

    for _ in range(count):
        print(message)

# When using keyword arguments,
# no error occurs even if the order of the arguments
# is different from the defined order of the parameters.
repeat_print(count=3, message="Hello")
```
```python
Hello
Hello
Hello
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
We can also set default values for parameters. 
If an argument is not provided for a parameter that has a default value, Python will automatically use that default. 
This means you don't have to supply every argument for every function call.
```python
def repeat_print(message="Hi", count=1):
    """Prints the message 'count' number of times."""
    
    for _ in range(count):
        print(message)
    print() # For a newline

# Call with no arguments; both defaults are used.
repeat_print()

# Call with one positional argument; the default for 'count' is used.
repeat_print("Hello")

# Call with one keyword argument; the default for 'message' is used.
repeat_print(count=2)
```
```python
Hi

Hello

Hi
Hi
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
When using positional arguments, if you provide fewer arguments than the total number of parameters, the arguments are assigned to the parameters from left to right.
```python
# Order: message, count
def repeat_print(message="Hello", count=1):
    """Prints message count times"""
    for _ in range(count):
        print(message)

repeat_print(3)
```
```python
3
```
<br>
```python
# Order: count, message
def repeat_print(count=1, message="Hello"):
    """Prints message count times"""
    for _ in range(count):
        print(message)

repeat_print(3)
```
```python
Hello
Hello
Hello
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
We do not have to set a default value for every parameter, but parameters without default values must come before parameters with default values. 
It is standard practice to place required parameters (those that must always receive an argument) further to the left in the function definition.
```python
# 'message' (no default) comes before 'count' (has a default).
def repeat_print(message, count=1):
    """Prints the message 'count' number of times."""
    for _ in range(count):
        print(message)
```
{% include end-box.html %}

{% include end-box.html %}

# 3.Duck typing
{% include start-box.html class="math-box"%}
`"If it walks like a duck and it quacks like a duck, then it must be a duck."`

This phrase is often used to describe the nature of dynamic typing in Python.

In the context of function parameters, it means that the function doesn't care about the specific data type of an argument. As long as the argument can perform the actions required of it inside the function, it is considered valid.

This has the advantage of making Python programming very flexible and convenient. On the other hand, it has the disadvantage of making it difficult to prevent objects from being used in unintended ways.

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
The function works correctly as long as the object passed to message supports the `len()` function and slicing. However, an error will occur if an object of a data type that does not support these operations is provided.
```python
def print_triangle(message):
    for i in range(len(message) + 1):
        print(message[:i])

# Works with a string
print_triangle("Hello?")
print("-" * 20)

# Works with a list
print_triangle(["Apple", "Banana", "Mandarin"])
print("-" * 20)

# Causes an error with an integer
print_triangle(123)
```
```python
H
He
Hel
Hell
Hello
Hello?
--------------------
[]
['Apple']
['Apple', 'Banana']
['Apple', 'Banana', 'Mandarin']
--------------------
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Cell In[3], line 16
     13 print("-" * 20)
     15 # Causes an error with an integer
---> 16 print_triangle(123)

Cell In[3], line 3
      2 def print_triangle(message):
----> 3     for i in range(len(message) + 1):
      4         print(message[:i])

TypeError: object of type 'int' has no len()
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
It can be difficult to detect in advance when a function will operate differently from the user's intention.
```python
def repeat_print(message="Hello", count=1):
    """Prints the message 'count' number of times."""
    
    for _ in range(count):
        print(message)

repeat_print(3)
```
```python
3
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
To prevent a function from behaving differently than intended, we can supplement its definition with **_type hinting_**, a way to provide hints about the expected data types of parameters and return values.
```python
# Initialize parameters along with their data types in the function declaration.
def repeat_print(message: str = "Hello", count: int = 1) -> None: # '-> None' means the function returns None.
    """Prints the message 'count' number of times."""
    
    for _ in range(count):
        print(message)

# This call now works as intended, and a type checker would see it as valid.
repeat_print(count = 3)
```
```python
Hello
Hello
Hello
```
{% include end-box.html %}
{% include end-box.html %}

# 4.When the number of arguments can vary
{% include start-box.html class="math-box"%}
If you want to pass a varying number of arguments into a single parameter, the most straightforward method is to pass them inside a container (like a list or tuple). Arguments that can change in length like this are called **_variable-length arguments_**.

## 4-1) Tuple
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
Pass a single tuple as the argument.
```python
def print_many(my_tuple):
    print(my_tuple)

print_many((1, 2, 3, 4, 5))
```
```python
(1, 2, 3, 4, 5)
```
<br>
If we simply pass multiple arguments, an error will occur. This is because the number of arguments does not match the number of parameters.
```python
def print_many(my_tuple):
    print(my_tuple)

print_many(1, 2, 3, 4, 5)
```
```python
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Cell In[2], line 6
      1 def print_many(my_tuple):
      3     print(my_tuple)
----> 6 print_many(1, 2, 3, 4, 5) 

TypeError: print_many() takes 1 positional argument but 5 were given
```
<br>
If we prefix a parameter name with an asterisk (`*`), it will collect all the positional arguments into a `tuple`.
```python
def print_many(*arguments):
    print(type(arguments))
    print(arguments)

print_many(1, 2, 3, 4, 5)
```
```python
<class 'tuple'>
(1, 2, 3, 4, 5)
```
<br>
If you pass a single tuple to a parameter that uses *args, the result is a new tuple that contains the passed tuple as its single item.
```python
def print_many(*arguments):
    print(type(arguments))
    print(arguments)

# Here, ONE argument (a tuple) is passed to the function.
print_many((1, 2, 3, 4, 5))
```
```python
<class 'tuple'>
((1, 2, 3, 4, 5),)
```
{% include end-box.html %}

## 4-2) Dictionary
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
The traditional way to pass a `dictionary` as a single argument.
```python
def print_many(my_dict):
    print(type(my_dict))
    for k in my_dict:
        print(k, ":", my_dict[k])

print_many({"a": 65, "b": 66})
```
```python
<class 'dict'>
a : 65
b : 66
```
<br>
If you prefix a parameter name with a double asterisk (`**`), it will collect all the keyword arguments into a `dictionary`. It's important to note that you use an equals sign (`=`) for the arguments (not a colon `:`), and the keywords automatically become the `str` keys of the dictionary.
```python
def print_many(**keywords):
    print(type(keywords))
    for k in keywords:
        print(k, ":", keywords[k])

print_many(a = 65, b = 66)
```
```python
<class 'dict'>
a : 65
b : 66
```
<br>
Passing a dictionary literal directly to a parameter that uses the `**` syntax will cause an error.
```python
def print_many(**my_dict):
    print(type(my_dict))
    for k in my_dict:
        print(k, ":", my_dict[k])

print_many({"a":65, "b": 66})
```
```python
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Cell In[10], line 8
      4     for k in my_dict:
      5         print(k, ":", my_dict[k])
----> 8 print_many({"a":65, "b": 66})

TypeError: print_many() takes 0 positional arguments but 1 was given
```
{% include end-box.html %}
{% include end-box.html %}

# 5.Unpacking operator
{% include start-box.html class="math-box"%}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
Unpacking operator: `*`
```python
my_list = [1, 2, 3]

# Without unpacking, this prints the list object itself.
print(my_list)

# With unpacking, this passes the items as individual arguments.
print(*my_list)
```
```python
[1, 2, 3]
1 2 3
```
<br>
We can also use the `*` operator to unpack iterables into a new `list`. This is a powerful and readable way to combine or merge multiple lists.
```python
my_list1 = [1, 2, 3]
my_list2 = [4, 5, 6]

# Without unpacking, this creates a nested list (a list of lists).
my_list_nested = [my_list1, my_list2]
print(my_list_nested)

# With unpacking, this creates a single, flattened list.
my_list_flat = [*my_list1, *my_list2]
print(my_list_flat)
```
```python
[[1, 2, 3], [4, 5, 6]]
[1, 2, 3, 4, 5, 6]
```
<br>
We can also unpack a single `list` to provide multiple arguments to a function.
```python
def add_three(a, b, c):
    print("a =", a)
    print("b =", b)
    print("c =", c)
    return a + b + c

# The * operator unpacks the list into individual arguments.
# This call is equivalent to add_three(1, 2, 3)
add_three(*[1, 2, 3])
```
```python
a = 1
b = 2
c = 3
6
```
<br>
When you unpack a `dict` with the single asterisk (`*`) operator, only its `keys` are passed as arguments.
```python
def add_three(a, b, c):
    print("a =", a)
    print("b =", b)
    print("c =", c)
    return a + b + c

# Unpacking a dictionary with * passes its keys as positional arguments.
add_three(*{"A": 1, "B": 2, "C": 3})
```
```python
a = A
b = B
c = C
'ABC'
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
Unpacking operator: `**`<br>
If We want to unpack a `dict` so that its keys match the function's parameter names and its values are passed as arguments, we must use the double asterisk (`**`) operator.
```python
Dict = {**{"a": 1, "b": 2, "c":3}}
Dict
```
```python
{'a': 1, 'b': 2, 'c': 3}

```
<br>
```python
def add_three(a, b, c):
    return a + b + c

my_dict = {'a': 1, 'b': 2, 'c': 3}

# The ** operator unpacks the dictionary into keyword arguments.
result = add_three(**my_dict)

print(result) 
```
```python
6
```
<br>
```python
def add_three(a, b, c):

    print("a = ", a)
    print("b = ", b)
    print("c = ", c)

    return a + b + c

add_three(**{"a": 1, "b": 2, "c":3})
```
```python
a =  1
b =  2
c =  3

6
```
<br>
However, when you unpack a dictionary using `**`, the keys of the dictionary must match the parameter names in the function definition. If they don't, an error will occur.
```python
def add_three(a, b, c):

    print("a = ", a)
    print("b = ", b)
    print("c = ", c)

    return a + b + c

add_three(**{"i": 1, "j": 2, "k":3})
```
```python
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Cell In[35], line 10
      5     print("c = ", c)
      7     return a + b + c
---> 10 add_three(**{"i": 1, "j": 2, "k":3})

TypeError: add_three() got an unexpected keyword argument 'i'
```
<br>
```python
def add_three(i, j, k):

    print("i = ", i)
    print("j = ", j)
    print("k = ", k)

    return i + j + k

add_three(**{"i": 1, "j": 2, "k":3})
```
```python
i =  1
j =  2
k =  3

6
```
{% include end-box.html %}
{% include end-box.html %}
{% include end-box.html %}

# 6.Return
{% include start-box.html class="math-box"%}
Every function in Python must return a value. 
If a function reaches its end without an explicit return statement, Python automatically returns the special value `None`.

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
A function that doesn't have an explicit return statement will automatically return `None` after it has finished executing.
```python
def repeat_print(message="Hello", count=1):
    """Prints the message 'count' number of times."""
    
    for _ in range(count):
        print(message)
    
    # Python implicitly adds 'return None' here

result = repeat_print("hi", 3)
print(result)
```
```python
hi
hi
hi
None
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
We can also `return` from the middle of a function. 
When a function encounters a `return` statement, it exits immediately and control is passed back to the place where the function was called.
```python
def compute_tax(my_income):
    """Calculates tax based on income"""
    
    if my_income <= 12:
        return my_income * 0.06
    elif my_income <= 46:
        return my_income * 0.15 - 1.08
    else:
        # As soon as one of these return statements is hit,
        # the function stops and sends the value back.
        return my_income * 0.24 - 5.22

# (Assuming the user inputs 30)
my_income = float(input("Please enter your annual income: "))
tax = compute_tax(my_income)

print("The tax you need to pay is", tax, ".")
```
```python
Please enter your annual income: 10
The tax you need to pay is 0.6 .
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
When a function has multiple return values, they are implicitly returned as a `tuple`.
```python
import random

def two_random_numbers():
    # When you list values separated by commas, Python "packs" them into a tuple.
    return random.random(), random.random()

# The return value is a single tuple object.
my_tuple = two_random_numbers()
print(type(my_tuple))
print(my_tuple)

# It's also common to unpack the return value directly.
a, b = two_random_numbers()
```
```python
<class 'tuple'>
(0.3256079511115426, 0.14147072324908772)
```
<br>
```python
import random

def two_random_numbers():
    # When you list values separated by commas, Python "packs" them into a tuple.
    return (random.random(), random.random())

# The return value is a single tuple object.
my_tuple = two_random_numbers()
print(type(my_tuple))
print(my_tuple)

# It's also common to unpack the return value directly.
a, b = two_random_numbers()
```
```python
<class 'tuple'>
(0.2642356322591809, 0.8007220248176269)
```
<br>
We can also use a `list` as a return type.
```python
import random

def two_random_numbers():
    # When you list values separated by commas, Python "packs" them into a tuple.
    return [random.random(), random.random()]

# The return value is a single tuple object.
my_tuple = two_random_numbers()
print(type(my_tuple))
print(my_tuple)

# It's also common to unpack the return value directly.
a, b = two_random_numbers()
```
```python
<class 'list'>
[0.2196592612735997, 0.5356319775383562]
```
{% include end-box.html %}
{% include end-box.html %}

# 7.Call by Object Reference
{% include start-box.html class="math-box"%}
In Python, when you call a function, a reference to the object is passed as the argument. 
In other words, the parameter inside the function becomes another name for the same object that was passed in, avoiding the need to create a new copy.

## 7-1) Immutable Objects
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
When the parameter refers to an immutable object (like an `int`, `str`, or `tuple`), any operation that seems to modify it inside the function actually creates a new object. 
Therefore, the original object passed as an argument is not affected.
```python
def my_func(a):
    # At this point, 'a' is another name pointing to the same object as 'x'.
    # Because integers are immutable, 'a += 100' creates a NEW integer object (101) and reassigns the local variable 'a' to point to it.
    a += 100
    return a

x = 1
print(x)

result = my_func(x)
print(result)

# The original 'x' still points to the unchanged object '1'.
print(x)
```
```python
1
101
1
```
{% include end-box.html %}

## 7-2) Mutable Objects
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
If the object passed as an argument is mutable (like a `list`), it can be changed from within the function through the parameter that refers to it.
```python
def append_hello(func_list):
    print("Inner function id:", id(func_list))
    # This modifies the original object in-place.
    func_list.append("hello")

my_list = ["a"]
print("Before id:", id(my_list), my_list)

append_hello(my_list)
print("After id:", id(my_list), my_list)

print(my_list)
```
```python
Before id: 2740919467584 ['a']
Inner function id: 2740919467584
After id: 2740919467584 ['a', 'hello']
['a', 'hello']
```
As you can see, the ID never changes because `my_list` (outside the function) and `func_list` (inside the function) are just two different names pointing to the exact same list object in memory. 
Modifying it in one place makes the change visible everywhere.
<br>
Modifying a mutable object that was created outside a function from within that function can sometimes cause unexpected side effects. To make it clearer that the object is being changed, it's a common convention to `return` the modified object.

This doesn't change the underlying behavior, but it makes the function's intent more explicit to the person calling it.
```python
def append_hello(func_list):
    print("Inner function id:", id(func_list))
    func_list.append("hello")
    return func_list # Explicitly return the modified object

my_list = ["a"]
print("Before id:", id(my_list), my_list)

# The list is still modified in-place
append_hello(my_list) 

print("After id:", id(my_list), my_list)

# Even with the added return, the original list is still modified.
```
```python
Before id: 2740919961024 ['a']
Inner function id: 2740919961024
After id: 2740919961024 ['a', 'hello']
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Shallow Copy**<br>
When calling a function, we can pass a copy of a `list` instead of the original. 
However, the `.copy()` method does not create new copies of the items inside the list. 
This is why it's called a **_shallow copy_**.
```python
def append_hello(func_list):
    print("Inner function id:", id(func_list), id(func_list[0]))
    func_list.append("hello")
    return func_list

my_list = [[1, 2], "a"]
print("Before id:", id(my_list), id(my_list[0]))

# Pass a shallow copy of the list to the function
new_list = append_hello(my_list.copy()) 
print("After id:", id(new_list), id(new_list[0]))

print(my_list)
print(new_list)

# A new list is created, but the items within it are reused.
```
```python
Before id: 255053656704 2550553245760
Inner function id: 2550553246272 2550553245760
After id: 2550553246272 2550553245760
[[1, 2], 'a']
[[1, 2], 'a', 'hello']
```
Notice that while the outer list `id` is different, the `id` of the inner list `[1, 2]` remains the same. 
The shallow copy created a new container but reused the references to the objects inside.
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Deep Copy**<br>
Using deepcopy from the copy module, we can create a copy that includes new copies of the items as well.
```python
import copy

def append_hello(func_list):
    print("Inner function id:", id(func_list), id(func_list[0]))
    func_list.append("hello")
    return func_list

my_list = [[1, 2], "a"]
print("Before id:", id(my_list), id(my_list[0]))

# Pass a deep copy of the list to the function
new_list = append_hello(copy.deepcopy(my_list))
print("After id:", id(new_list), id(new_list[0]))

print(my_list)
print(new_list)

# When you use deepcopy, even the items are copied as new objects, so their addresses will be different.
# However, it has the disadvantage of using more memory, so be careful with large datasets.
```
```python
Before id: 25505531601344 2550553655296
Inner function id: 2550553232512 2550553656704
After id: 2550553232512 2550553656704
[[1, 2], 'a']
[[1, 2], 'a', 'hello']
```
With `copy.deepcopy()`, a completely new object was created for the inner list as well, so you can see that the ID of the list's first item is now different from the original.
<br>
We can also perform the copying operation inside the function itself.
```python
import copy

def append_hello(func_list):
    # Deep copy inside the function
    func_list = copy.deepcopy(func_list) 
    print("Inner function id:", id(func_list))
    func_list.append("hello")
    return func_list

my_list = [[1, 2], "a"]
print("Before id:", id(my_list), id(my_list[0]))

new_list = append_hello(my_list)
print("After id:", id(new_list), id(new_list[0]))

print(my_list)
print(new_list)
```
```python
Before id: 2740919801792 2740919632320
Inner function id: 2740919456384
After id: 2740919456384 2740919961024
[[1, 2], 'a']
[[1, 2], 'a', 'hello']
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Function Return Values**
When a function returns a value, it also returns a reference to the object. 
This is more efficient than creating a new copy.
```python
def make_list():
    # An object is created inside the function
    temp = []
    print(id(temp))
    return temp

# 'new_list' becomes a new name for the object created inside the function
new_list = make_list()
print(id(new_list))
```
```python
2740919644096
2740919644096
```
The `id` is the same because the `return` statement passes a reference to the `temp` object, and `new_list` now points to that same object.
<br>
We need to be extremely careful when using a mutable object (like a `list` or `dict`) as a default argument.
```python
# [Warning] Using a mutable object as a default argument.
# The default object is reused across all calls.
def f(a, my_list=[]):
    my_list.append(a)
    return my_list

print(f(1))
print(f(2))
print(f(3))

# The default 'my_list' is not created new each time; the same one is reused.
```
```python
[1]
[1, 2]
[1, 2, 3]
```
Default argument values are evaluated only once, at the time the function is defined, not each time it is called.

This means a single list object (`[]`) is created when `def f(...)` is run. Every subsequent call to `f()` that doesn't provide its own list will use and modify that same, shared list object.
{% include end-box.html %}
{% include end-box.html %}

# 8.Variable Scope
{% include start-box.html class="math-box"%}
## 8-1) Local Variables
A variable defined inside a function is called a **_local variable_**, meaning it can only be used within that function's local scope.
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
Example of local variable, not a parameter.
```python
def my_func():
    x = 1 # A local variable, not a parameter
    print(x)

my_func()
```
```python
1
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
We cannot use a local variable outside of the function.
```python
# Run after restarting the kernel
def my_func():
    x = 1 # A local variable, not a parameter
    print(x)

my_func()
print(x) # NameError: name 'x' is not defined (cannot use x outside the function)
```
```python
1

---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
Cell In[16], line 7
      4     print(x)
      6 my_func()
----> 7 print(x) # NameError: name 'x' is not defined (cannot use x outside the function)

NameError: name 'x' is not defined
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
We can use local variables with the same name in different functions. 
Although it might be confusing to us because the names are the same, from Python's perspective, they are different variables because they were defined in different functions.
```python
def my_func1():
    x = ["A"]
    print(x, id(x))

def my_func2():
    x = ["A"]
    print(x, id(x))

my_func1()
my_func2()
```
```python
['A'] 2550553962880
['A'] 2550553163136
```
{% include end-box.html %}

## 8-2) Global Variables
A variable defined outside of any function is called a **global variable**, meaning it can be accessed from anywhere. 
However, a function can only use a global variable that has been defined at the time the function is executed.
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
```python
y = 7 # A global variable

def my_func1():
    print(y, id(y))
    
def my_func2():
    print(y, id(y))

my_func1()
my_func2()
```
```python
7 25504880437680
7 25504880437680
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
If you assign a value to a variable inside a function that has the same name as a global variable, Python treats it as a new local variable. If you try to access it before it's assigned, Python prevents you from accidentally using the global variable. This is because, within a function, a local variable takes precedence over a global variable of the same name.
```python
x = 1

def my_func():
    print(x) # Error occurs here
    x = 10

my_func()
```
```python
---------------------------------------------------------------------------
UnboundLocalError                         Traceback (most recent call last)
Cell In[19], line 7
      4     print(x) # Error occurs here
      5     x = 10
----> 7 my_func()

Cell In[19], line 4
      3 def my_func():
----> 4     print(x) # Error occurs here
      5     x = 10

UnboundLocalError: local variable 'x' referenced before assignment
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
If a global variable and a local variable have different names, you can use both inside the function.
```python
y = 7 # A global variable

def my_func():
    x = 10
    print(x)
    print(y)

my_func()
```
```python
10
7
```
<br>
When there is a local variable with the same name as a global variable, the function will only use the local variable. Outside the function, the global variable is used.
```python
x = 1

def my_func():
    x = 10
    print(x)

my_func()
print(x)
```
```python
10
1
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
If you want to modify a global variable from inside a function, you can use the `global` keyword.
```python
def my_func():
    global x # Declare that x is the global variable, not a new local one.
    x = 100  # Therefore, this assigns a new value to the global variable x.
    print(x)

x = 1
print(x)

my_func()
print(x) # The change made inside the function is maintained.
```
```python
1
100
100
```
<br>
For a global variable that is a **mutable object** (like a list), you can modify it from inside a function even without the `global` keyword.
```python
def my_func():
    # global x # The result would be the same
    x.append("C")
    print(x)

x = ["A"]
print(x)
my_func()
print(x)
```
```python
['A']
['A', 'C']
['A', 'C']
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
However, even for a mutable global variable, if you create a new object and assign it to the variable inside a function, it becomes a **new local variable**.
```python
x = ["A"]
print(x)

def my_func():
    x = ["C"] # This creates a new local list 'x'
    print(x)

my_func()
print(x)
```
```python
['A']
['C']
['A']
```
<br>
You can use the `global` keyword to create a new object and reassign the global variable to it.
```python
x = ["A"]
print(x)

def my_func():
    global x
    x = ["C"] # This reassigns the global variable 'x' to a new list
    print(x)

my_func()
print(x)
```
```python
['A']
['C']
['C']
```
{% include end-box.html %}

[Note] Python follows the LEGB rule for the priority in which it searches for names.<br>
1.Local scope
<div class="indented-paragraph" markdown="1">
The innermost scope. This includes all the variables and parameters defined inside the current function.
</div>

2.Enclosing scope
<div class="indented-paragraph" markdown="1">
The scope of any enclosing functions. This is relevant for nested functions; Python will check the scope of the parent function(s).
</div>

3.Global scope
<div class="indented-paragraph" markdown="1">
The top-level scope of the current module or script. This is for variables defined outside of all functions.
</div>

4.Built-in scope
<div class="indented-paragraph" markdown="1">
The outermost scope that contains all of Python's built-in names like `print()`, `len()`, `str`, and `list`.
</div>
{% include end-box.html %}

# 9.Recursion
{% include start-box.html class="math-box"%}
Just as a function can call other functions, it can also call itself. 

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Example of recursion.**
```python
def my_func():
    x = []
    print("my_func", id(x))
    my_func()

# my_func() # This would run forever
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Termination condition**<br>
To prevent infinite recursion, every recursive function must have a base case—a condition under which it stops calling itself.
The position of the recursive call relative to other statements in the function determines the order of execution.

Action after the recursive call The `print()` happens after the recursive call returns. This means `print(1)` executes first, then `print(2)`, and finally `print(3)`.
```python
def my_func(count):
    if count > 0:
        my_func(count - 1)
    print(count)

my_func(3)
```
```python
1
2
3
```
<br>
Action before the recursive call The `print()` happens before the next recursive call. This means `print(3)` executes first, then `print(2)`, and finally `print(1)`.
```python
def my_func(count):
    if count > 0:
        print(count)
        my_func(count - 1)

my_func(3)
```
```python
3
2
1
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Example: The Fibonacci Sequence**<br>
Recursion is a natural way to solve problems that can be broken down into smaller, self-similar sub-problems. 
The Fibonacci sequence is a classic example.

If we define a function `f(n)` that calculates the n-th Fibonacci number:
- If `n = 0`, then `f(n) = 0`

- If `n = 1`, then `f(n) = 1`

- If `n > 1`, then `f(n) = f(n-1) + f(n-2)`
```python
def fibonacci(n):
    # The recursive step
    if n > 1:
        return fibonacci(n-1) + fibonacci(n-2)
    # The base case for n = 1
    elif n == 1:
        return 1
    # The base case for n = 0
    else:
        return 0

for n in range(0, 11):
    print(fibonacci(n), end=" ")
```
```python
0 1 1 2 3 5 8 13 21 34 55
```
{% include end-box.html %}
{% include end-box.html %}

# 10. Function Object
{% include start-box.html class="math-box"%}
In Python, functions are also objects. This allows you to structure your code flexibly and improve its efficiency.
- You can save a function to a variable and use it later.
- This also means you can put a function inside a container like a list or dictionary.

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Example of function object**
```python
from datetime import datetime

def print_date():
    today = datetime.today()
    print(f"Today is {today.month} / {today.day} {today.year}.")

# Initialize a variable with a reference to the function object
my_func = print_date

# Call the function using the new variable name
my_func()
```
```python
Today is 10 / 17 2025.
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Passing Functions as Arguments**
We can pass a function object as an argument to another function.
```python
from datetime import datetime

def print_date():
    today = datetime.today()
    print(f"Today is {today.month} / {today.day}, {today.year}.")

def print_time():
    current_time = datetime.now()
    print(f"It is now {current_time.hour}:{current_time.minute}.")

def do_something(my_func):
    # The function passed as an argument is called here
    my_func()

# Pass the print_date function as an argument.
# It will be executed inside do_something.
do_something(print_date)

# Pass the print_time function as an argument.
do_something(print_time)
```
```python
Today is 10 / 17, 2025.
It is now 10:6.
```
{% include end-box.html %}


{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Returning Functions from Functions (Closures)**<br>
A function can also return another function.
```python
def func_maker(message):
    # This is a nested function
    def speaker():
        print(message)
    # Return the nested function object
    return speaker

# my_func becomes a reference to the 'speaker' function.
my_func = func_maker("What can I do for you?")

# Since speaker() has no arguments, my_func() is also called without arguments.
my_func()

# This structure, where a function (speaker) uses a variable (message) from its enclosing scope, is called a closure.
```
```python
What can I do for you?
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Using Functions in a Dictionary (Callbacks)**
A common pattern is to store function objects in a dictionary to call them based on a specific key, such as user input.

Create a program that prints the date for the input "date" and the time for the input "time".
```python
from datetime import datetime

def print_date():
    today = datetime.today()
    print(f"Today is {today.month} / {today.day}, {today.year}.")

def print_time():
    current_time = datetime.now()
    print(f"It is now {current_time.hour}:{current_time.minute}.")

# The dictionary values are the function objects themselves
command_callbacks = {"date": print_date, "time": print_time}

user_command = input("Input your command (date/time):")

# The value from the dictionary is a function object, so we add parentheses () to execute it.
command_callbacks[user_command]()
```
```python
Today is 10 / 17, 2025.
```

**Important Distinction: `func` vs. `func()`**<br>
It's crucial to understand the difference between referencing a function and calling it.
- `a = my_func()` executes the function and assigns its return value to `a`.
- `f = my_func` assigns a reference to the function object `my_func` to the variable `f`. The function is not executed.

If you add parentheses `()` to the function names when creating the dictionary, the functions will be executed immediately, and their return values (which are `None` in this case) will be stored in the dictionary. This is a common mistake.

```python
# MISTAKE: The functions are called immediately
command_callbacks = {"date": print_date(), "time": print_time()}
```
The code above will print both the date and time as soon as the dictionary is created, not when the user provides input.
{% include end-box.html %}
{% include end-box.html %}

# 11.Anonymous Functions (Lambda Expressions)
{% include start-box.html class="math-box"%}
A short and simple function consisting of a single expression can be used concisely without being assigned a name. 
An anonymous function is called a **_lambda expression_** or a **_lambda function_**. 

Lambda expressions use the `lambda` keyword. 

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
For example, a function that takes `x` and `y` as input and returns their sum can be created as follows: `lambda x, y: x + y`
```python
# 1. Assign it to a variable, just like a regular function
my_func = lambda x, y: x + y
my_func(1, 2)
```
```python
3
```
<br>
```python
# 2. Pass it as an argument to another function
def do_something(my_func):
    my_func()

# The lambda here is a function that takes no arguments and runs print().
do_something(lambda: print("Hello, world"))
```
```python
Hello, world
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Using Lambdas with Built-in Functions**<br>
Lambdas are particularly convenient when used with built-in functions like `map()`, `filter()`, `sorted()`, and `reduce()`.

The `map()` function applies a given function to each item of an iterable.
```python
add_100 = lambda x: x + 100

# The first argument to map() is the function to apply.
# The second argument is the iterable to apply it to.
# You must specify a container for the result of map().
list(map(add_100, [1, 2, 3, 4]))
```
```python
[101, 102, 103, 104]
```
<br>
```python
add_100 = lambda x: x + 100

# For a simple function, it's more concise to define the lambda inline.
list(map(lambda x: x + 100, [1, 2, 3, 4]))
```
```python
[101, 102, 103, 104]
```
<br>
```python
add_100 = lambda x: x + 100

# When applying a function with multiple parameters, you must provide multiple iterables.
list(map(lambda x, y: x + y, [1, 2, 3, 4], [5, 6, 7, 8]))
```
```python
[6, 8, 10, 12]
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
The `filter()` function constructs an iterator from elements of an iterable for which a function returns `True`.
```python
# The filter() function filters the elements of the iterable based on the condition in the lambda.
# The boolean value returned by the lambda determines whether the item is included.
list(filter(lambda x: x % 2 == 0, [1, 2, 3, 4, 5]))
```
```python
[2, 4]
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
The `reduce()` function applies a function of two arguments cumulatively to the items of a sequence, reducing the sequence to a single value.
```python
from functools import reduce

add = lambda x, y: x + y
reduce(add, [1, 2, 3, 4])

# The value accumulates until only one item remains.
# [add(1, 2), 3, 4] -> [3, 3, 4]
# [add(3, 3), 4] -> [6, 4]
# [add(6, 4)] -> [10]
```
```python
10
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
We can also use a lambda to specify a custom sorting criterion for the `sorted()` function.
```python
my_dict = {"apple": 3, "Alpha": 100, "Drive": 10, "data": 33, "Billy": 50}

# Sorting a dictionary with sorted() sorts the keys and returns a list.
sorted(my_dict)
```
```python
['Alpha', 'Billy', 'Drive', 'apple', 'data']
```
<br>
```python
my_dict = {"apple": 3, "Alpha": 100, "Drive": 10, "data": 33, "Billy": 50}

# To sort by value instead of key, we can use a lambda with the 'key' argument.
# For each item (a key-value tuple), the lambda returns the value (item[1]) to be used for sorting.
dict(sorted(my_dict.items(), key=lambda item: item[1]))
```
```python
{'apple': 3, 'Drive': 10, 'data': 33, 'Billy': 50, 'Alpha': 100}
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
**Sum of Digits**<br>
Solve it using the `reduce()` and recursive functions. 
This exercise is designed to explore various syntaxes rather than to improve code quality.

The problem is to repeatedly sum the digits of a given natural number until only one digit remains. For example, if the input is `1357`: `1+3+5+7 = 16`, and then `1+6 = 7`.

**Step 1**: Recursive Solution Instead of the `while` loop used previously, let's try a recursive call.
```python
# Recursive solution
def add_digits(num: int) -> int:
    print(num)
    if num < 10:
        return num
    else:
        return add_digits(sum([int(x) for x in str(num)]))

add_digits(13567)
```
```python
13567
22
4
```
<br>
**Step 2**: Using `reduce()` in the recursive solution Now let's replace the list comprehension with `reduce()`.
```python
from functools import reduce

def add_digits(num: int) -> int:
    print(num)
    if num < 10:
        return num
    else:
        # Use reduce and a lambda to sum the digits
        return add_digits(reduce(lambda x, y: int(x) + int(y), str(num)))

add_digits(13567)
```
```python
13567
22
4
```
{% include end-box.html %}
{% include end-box.html %}