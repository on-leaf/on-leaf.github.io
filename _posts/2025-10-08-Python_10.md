---
layout: single
title:  "10.Repetitive statement"
category: "Python"
tag: [Python]
header:
  teaser: #../images/2025-07-08-CT_6/image-20250708184503610.png
toc: true
toc_sticky: true
toc_label: CONTENTS
toc_icon: "fa-solid fa-seedling" # More icons: https://fontawesome.com/v6/search?ic=free
author_profile: false
sidebar:
    nav: "counts"
search: true # Change true to false if you don't want to have this article be searched 
redirect_from:
    - /Python/Python_10
use_math: true
---

**[Reference]** <br>
$\bullet$ [홍정모의 파이썬 프로그래밍 추월코스](https://www.honglab.ai/courses/python)<br>
This post is written based on above lecture.<br>
All contents in this post are not the same with above lecture.<br>
Please show the detail at the his lecture.
{: .notice--success}

# Introduction
{% include start-box.html class="math-box"%}
Let's explore methods for repetition, a part of program flow control. 
While there are words like 'repeat' and 'iterate' for repetition, programming often favors iterate. 
This is because it usually implies repetition with slight variations, which is more common than simply repeating the exact same thing. 
This is also known as creating a **_loop_**.

There are two main ways to create a loop for repetition: `for` and `while`. 
While they are theoretically interchangeable, their practical use cases differ.

- A `for` loop is generally used when the number of iterations or the range to loop over is known before the loop starts.
- A `while` loop is typically used when the loop needs to continue as long as a certain condition is true, rather than for a fixed number of times.
{% include end-box.html %}

# 1.`for` loop
{% include start-box.html class="math-box"%}
## 1-1) General form of `for` loop
Let's look at general form of `for` loop.
```python
for variable in iterable_object:
    # Statements to be repeated
else:
    # Statements to execute after the loop finishes (without a `break`)
```
Between `in` and `:`, we can place an iterable object—an object that can be looped over. For example, objects of numeric data types like `int` or `float` cannot be used here, but container types like `list` or `tuple` can. To iterate over a range of integers, we can create and use a `range` object. The `variable` is successively assigned each item provided by the iterable.

```python
# How to check if an object is iterable
from collections.abc import Iterable

isinstance(1, Iterable), isinstance([1, 2, 3], Iterable), isinstance(range(3), Iterable)
```
```python
(False, True, True)
```

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`for` loop
```python
for i in [8, 3, 5]:  # i will be assigned the values 8, 3, and 5 in sequence.
    j = i * 10
    print(j)
```
```python
80
30
50
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`else`<br>
In a `for` or `while` loop, the code in the `else` block is executed only if the loop completes its full sequence without being interrupted by a break statement. 
While the syntax looks similar to the `else` in an `if` statement, its meaning is completely different.
```python
for i in [8,3,5]:
    j = i*10
    print(j)
else:
    print("Done")
```
```python
80
30
50
Done
```
{% include end-box.html %}

## 1-2) `range`
We can create a range of integers using the `range()` function. It is typically used together with `for` loops.

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
Type of `range`
```python
type(range(5))
```
```python
range
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
Argument of `range()`: range(start, end, step)
```python
# If you provide only one number, it acts as the 'stop' value.
# In this case, the start defaults to 0 and the step defaults to 1.
for i in range(5):
    print(i, end=" ")
```
```python
0 1 2 3 4 
```
<br>
```python
# If you provide two numbers, they act as the 'start' and 'stop' values.
# The step defaults to 1.
for i in range(1, 6):
    print(i, end=" ")
```
```python
1 2 3 4 5 
```
<br>
```python
# You can skip numbers by providing a 'step' value.
for i in range(1, 6, 2):
    print(i, end=" ")
```
```python
1 3 5 
```
<br>
```python
# You can also use a negative step to count backward.
for i in range(5, 0, -2):
    print(i, end=" ")
```
```python
5 3 1 
```
<br>
```python
# Of course, a range object can be assigned to a variable.
r = range(3)
for i in r:
    print(i)
```
```python
0
1
2
```
{% include end-box.html %}

## 1-3) Use `for` loop with container
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`for` with `str`
```python
# Using with a String
for i in "Hello?":
    print(i)
```
```python
H
e
l
l
o
?
```
<br>
```python
# When 'end' is an empty string
for i in "Hello?":
    print(i, end="")
```
```python
Hello?
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`for` with `tuple`
```python
# Using with a Tuple
for i in (5, 7, 3):
    print(i)
```
```python
5
7
3
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`for` with `dict`
```python
# Looping over a dictionary (iterates through keys)
for k in {"White":"banana", "Blue":"apple"}:
    print(k)
```
```python
White
Blue
```
<br>
```python
# Dictionary .keys()
for k in {"White":"banana", "Blue":"apple"}.keys():
    print(k)
```
```python
White
Blue
```
<br>
```python
# Dictionary .values()
for v in {"White":"banana", "Blue":"apple"}.values():
    print(v)
```
```python
banana
apple
```
<br>
```python
# Let's check the data type of the items from .items()
for item in {"White":"banana", "Blue":"apple"}.items():
    print(item)
```
```python
('White', 'banana')
('Blue', 'apple')
```
<br>
```python
# You can unpack the items from .items()
for k, v in {"White":"banana", "Blue":"apple"}.items():
    print(f"{k} -> {v}")
```
```python
White -> banana
Blue -> apple
```
{% include end-box.html %}

## 1-4) Changing item of `list` using `for`
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
immutable item case
```python
my_list = [1, 2, 3]

print(my_list, id(my_list[0]), id(my_list[1]), id(my_list[2]))

for i in my_list:
    print("Before:", id(i), i)
    i *= 10
    print("After:", id(i), i)
    print()

print(my_list, id(my_list[0]), id(my_list[1]), id(my_list[2]))
```
```python
[1, 2, 3] 2269211394288 2269211394320 2269211394352
Before: 2269211394288 1
After: 2269211394576 10

Before: 2269211394320 2
After: 2269211394896 20

Before: 2269211394352 3
After: 2269211395216 30

[1, 2, 3] 2269211394288 2269211394320 2269211394352
```
Since `int` is an immutable type, changing its value creates a new object.
However, once a list is created, changing the original variables used to create it does not affect the elements inside the list.
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
mutable item case
```python
my_list = [[1], [2], [3]]

print(my_list, id(my_list[0]), id(my_list[1]), id(my_list[2]))

for i in my_list:
    i[0]*=2

print(my_list, id(my_list[0]), id(my_list[1]), id(my_list[2]))
```
```python
[[1], [2], [3]] 2269292876672 2269292524992 2269292877632
[[2], [4], [6]] 2269292876672 2269292524992 2269292877632
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
Changing immutable item using indexing
```python
my_list = [1, 2, 3]

print(my_list, id(my_list), id(my_list[0]), id(my_list[1]), id(my_list[2]))

for i in range(len(my_list)):
    my_list[i]*=2

print(my_list, id(my_list), id(my_list[0]), id(my_list[1]), id(my_list[2]))
```
```python
[1, 2, 3] 2269314292608 2269211394288 2269211394320 2269211394352
[2, 4, 6] 2269314292608 2269211394320 2269211394384 2269211394448
```
Immutable item can be changed by indexing.
{% include end-box.html %}

## 1-5) `for` loop with `if`
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`if` in `for` loop
```python
for num in range(6):
    if num%2 == 0:
        print("Even")
    else:
        print("Odd")
```
```python
Even
Odd
Even
Odd
Even
Odd
```
{% include end-box.html %}

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`for` loop in `if`
```python
user_input = 6

if user_input % 2 ==0 :
    for i in range(user_input):
        print("Even", end=" ")

```
```python
Even Even Even Even Even Even 
```
{% include end-box.html %}

## 1-6) Nested `for` loop
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
Summation of given nested list
```python
my_list = [[1, 2, 3], [4, 5], [6]]

my_sum = 0

for i in my_list:
    for j in i:
        my_sum += j

print(my_sum)
```
```python
21
```
<br>
Summation of given nested list and non-list item
```python
my_list = [[1, 2, 3], [4, 5], [6], 7]

my_sum = 0

for i in my_list:
    if isinstance(i, list):
        for j in i:
            my_sum += j
    else:
        my_sum += i

print(my_sum)
```
```python
28
```
{% include end-box.html %}

## 1-7) `enumerate()`
We can use `enumerate()` in a `for` loop when we need both the item and its index at the same time.
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
```python
my_list = ["White", "Blue", "Red"]

# enumerate()
for index, item in enumerate(my_list):
    print(f"Index {index}: Item - {item}")
    
```
```python
Index 0: Item - White
Index 1: Item - Blue
Index 2: Item - Red
```
<br>
```python
my_dict = {"White":"madarin", "Blue":"apple", "Red":"banana"}

# enumerate()
for index, item in enumerate(my_dict):
    print(f"Index {index}: Item - {item}")
    
```
```python
Index 0: Item - White
Index 1: Item - Blue
Index 2: Item - Red
```
{% include end-box.html %}
{% include end-box.html %}

# 2.`while` loop
{% include start-box.html class="math-box"%}
Let's look at the general form of a `while` loop.
```python
while condition:
    # Statements to execute while the condition is True
else:
    # Statements to execute after the loop finishes without a break
```
A `while` loop differs from a `for` loop in that you must explicitly provide a condition for it to continue. 
This condition can be any expression that evaluates to `True` or `False`. 
The loop will continue to execute as long as the condition is `True` and will terminate when it becomes `False`. 
If the condition is always `True`, the loop will run infinitely until it is forcibly stopped by the user.
```python
# An example of an infinite loop
while True:
    # This block will repeat forever
    pass
```
A `for` loop iterates over an iterable, which has a natural stopping point (e.g., a list stops after its last item). 
In contrast, when using a `while` loop, it is up to us to define the stopping condition precisely.
A `while` loop is ideal when its continuation depends on an unpredictable condition, such as how much time has passed or waiting for a specific random number to be generated. 

{% include start-box.html class="math-box-inner" font_size="0.8em"%}
A common way to control a `while` loop is to manually manage a counter.
```python
repeat = 3

counter = 0  # Initialize the counter.

while counter < repeat:
    print(f"This is iteration number {counter}.")
    counter += 1
else:
    # This block runs after the loop finishes without a 'break'.
    print(f"{counter} repetitions have been completed.")
```
```python
This is iteration number 0.
This is iteration number 1.
This is iteration number 2.
3 repetitions have been completed.
```
<br>
Also, counter can be decreased.
```python
repeat = 3

counter = repeat  # Initialize the counter.

while counter > 0:
    print(f"Countdown: {counter}")
    counter -= 1
else:
    # This block runs after the loop finishes without a 'break'.
    print(f"Countdown finished after {repeat} repetitions.")
```
```python
Countdown: 3
Countdown: 2
Countdown: 1
Countdown finished after 3 repetitions.
```
{% include end-box.html %}
{% include end-box.html %}

# 3.Other Flow Control Tools
{% include start-box.html class="math-box"%}
## 3-1) `break`
When a `break` statement is encountered inside a loop, the loop terminates immediately. 
It effectively "breaks out" of the loop. 
A colon (`:`) is not required after the `break` keyword.
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`break`
```python
for i in range(0, 1000):
    print(i)
    break
print("Finished.")
```
```python
0
Finished.
```
<br>
In a nested loop, `break` will only exit the innermost loop that it is in.
```python
for j in range(0, 3):
    print("Outer:", j)
    for i in range(10, 1000):
        print("Inner:", i)
        break # This only breaks the inner loop
```
```python
Outer 0
Inner: 10
Outer 1
Inner: 10
Outer 2
Inner: 10
```
<br>
`break` is almost always used with an `if` statement. It doesn't break out of the `if` statement itself, but rather breaks out of the enclosing loop that contains the `if`.
```python
for i in range(0, 1000):
    print(i)
    if i == 3:
        break
print("Finished.")
```
```python
0
1
2
3
Finished.
```
<br>
A common pattern for `while` loops is to set the main condition to `True` (creating what would otherwise be an infinite loop), and then provide a specific "escape condition" inside that uses `break`.
```python
while True:
    user_input = input("Type 'exit' to quit: ")
    if user_input == "exit":
        break
    print(f"You typed: {user_input}")
```
<br>
`break` can, of course, be used with `for` loops as well. However, with `for` loops, it's often better practice to define the iteration range correctly in advance so you don't need to forcibly break out of the loop. For example, if you only want to print numbers up to 5, it's better to set the range accordingly (e.g., `range(6)`) rather than using a larger range and breaking when the number is greater than 5.
```python
for i in range(0, 1000):
    if i > 5:
        break
    print(i)
```
```python
0
1
2
3
4
5
```
<br>
```python
for i in range(0, 6):
    print(i)
```
```python
0
1
2
3
4
5
```
<br>
If a loop is terminated by a `break` statement, the `else` block is ignored. 
```python
my_list = [0, 5, 2, 8, 3, 9, 11, 5, 2]

for i in my_list:
    print(i, end=" ")
    if i == 3:
        print("\nFound 3")
        break
else:
    print("\nDid not find 3")
```
```python
0 5 2 8 3 
Found 3
```
<br>
In this case, the number 3 is not in the list. The loop completes its entire sequence without ever hitting a `break` statement. Therefore, the `else` block is executed.
```python
# A case where the loop finishes naturally without encountering a break, because 3 is not in the list.
my_list = [0, 5, 2, 8, 9, 11, 5, 2]

for i in my_list:
    print(i, end=" ")
    if i == 3:
        print("\nFound 3")
        break
else:
    print("\nDid not find 3")
```
```python
0 5 2 8 9 11 5 2 
Did not find 3
```
{% include end-box.html %}
## 3-2) `continue`
When a `continue` statement is encountered, the loop immediately jumps to the beginning of the next iteration. It can be used in both `for` and `while` loops.
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
Use of `continue`
```python
for i in range(3):
    print("This is the first print statement.")
    continue
    # This line is never reached because 'continue' skips it.
    print("This is the second print statement.")
```
```python
This is the first print statement.
This is the first print statement.
This is the first print statement.
```
{% include end-box.html %}

## 3-3) `pass`
The `pass` statement is a null operation—it literally does nothing when it's executed. It's used as a placeholder when a statement is syntactically required, but you don't want any code to run. This is often useful for code that you plan to implement later. `pass` can be used anywhere a statement is required, including loops, conditional statements, functions, and classes.
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
`pass`
```python
for i in range(0, 5):
    if i % 2 == 0:
        print("Even")
    else:
        # 'pass' is used here to explicitly do nothing when the number is odd.
        pass
```
```python
Even
Even
Even
```
{% include end-box.html %}

## 3-4) The Walrus Operator `:=`
Key feature of the walrus operator (:=) is that it allows you to assign a value to a variable and use that value as an expression at the same time. This is why it's officially called the assignment expression operator.
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
A standard assignment (`=`) is a statement, not an expression. As such, the statement itself does not evaluate to a value.
```python
# This is an assignment statement.
word = "Hello"
```
<br>
With the walrus operator, the assignment itself is an expression that has a value.
```python
# This is an assignment expression.
(word := "Hello")
```
```python
'Hello'
```
{% include end-box.html %}
{% include start-box.html class="math-box-inner" font_size="0.8em"%}
The walrus operator is particularly useful for simplifying `while` loops that need to get a value and then check it.

1. Without the Walrus Operator<br>
First, let's look at the code without the walrus operator. This requires fetching the input and then checking it in a separate `if` statement.
```python
while True:
    word = input("Enter a word ('quit' to exit): ")
    if word == "quit":
        break
    print(word)
```
<br>
2. With the Walrus Operator<br>
The walrus operator makes this much more concise. It lets us capture the result of `input()` in the `word` variable and check its value in the same line. Parentheses are required here due to the operator's low precedence.
```python
while (word := input("Enter a word ('quit' to exit): ")) != "quit":
    print(word)
```
Both loops have the exact same behavior, but the second one is shorter and can be more readable once you are familiar with the operator.
{% include end-box.html %}
{% include end-box.html %}