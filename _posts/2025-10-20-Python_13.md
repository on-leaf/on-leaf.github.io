---
layout: single
title:  "13.File"
category: "Python"
tag: [Python]
header:
  teaser: #../images/2025-07-08-CT_6/image-20250708184503610.png
toc: true
toc_sticky: true
toc_label: CONTENTS
toc_icon: "fa-solid fa-seedling" # More icons: https://fontawesome.com/v6/search?ic=free
author_profile: false
sidebar:
    nav: "counts"
search: true # Change true to false if you don't want to have this article be searched 
redirect_from:
    - /Python/Python_13
use_math: true
---

**[Reference]** <br>
$\bullet$ [홍정모의 파이썬 프로그래밍 추월코스](https://www.honglab.ai/courses/python)<br>
This post is written based on above lecture.<br>
All contents in this post are not the same with above lecture.<br>
Please show the detail at the his lecture.
{: .notice--success}

# Introduction
{% include start-box.html class="math-box"%}
To provide data to the CPU and store the results, programs use main memory. 
Main memory is fast, but it is volatile (its contents are lost when the power is turned off). 
Secondary storage (like a Hard Disk Drive or Solid-State Drive) is a device that saves data persistently, allowing it to be used later. 
While SSDs have become more common, HDDs are still used.

A file is the basic unit for storing data in secondary storage and is managed by the operating system. 
Python's file I/O provides a general way to read data from or save data to a file.

(Note: Accessing data from memory is much faster than from an HDD or SSD. Even with an SSD, the speed difference can be significant.)
{% include end-box.html %}


# 1.Text File Input/Output
{% include start-box.html class="math-box"%}
A text file stores data in a human-readable format (a sequence of characters). 
The operating system helps us recognize it as a text file, for example, by using the `.txt` extension. 
This is a feature of the OS, not Python itself.

The general steps for using a file are as follows:

1. Open file: Request permission (a "handle") from the operating system to use the file.

2. Write/Read: Write data to the file (from memory) or read data from the file (into memory).

3. Close file: Return the file resource to the operating system.

The built-in `open()` function is used to request a file handle from the OS. 
```python
myfile = open("myfile.txt", "wt")
``` 
Here, `"myfile.txt"` is the file name, and `"wt"` specifies the mode. 
`w` means write mode, and `t` means text mode.

After you are finished with the file, we must use the `close()` method to return the resource to the operating system.

## 1-1) Writing to a File
```python
# open("myfile.txt", "wt"): Means opening 'myfile.txt' for writing.
# wt: write text
# If no file with this name exists, it's created. If it does exist,
# its contents are erased and it starts fresh.
myfile = open("myfile.txt", "wt")

# Write the strings you want to save.
myfile.write("First line")
myfile.write("\n") # newline
myfile.write("Second line")
myfile.write("\n") # newline
myfile.write("Third line")

# Close the file.
myfile.close()
```

## 1-2) Reading a File
```python
# Open the file using its name.
# The extension is just part of the name; it has no special meaning to Python.
# "rt" means "read text". The 't' can often be omitted.
myfile = open("myfile.txt", "rt")

# Read the entire contents of the file.
# The .read() method reads the entire content of a text file
# and returns it as a single string.
text = myfile.read()
myfile.close()

# 'text' is a str object because the file was opened in text mode.
print(type(text))
print(text)
```
```python
<class 'str'>
First line
Second line
Third line
```
<br>
If a file with the specified name does not exist, an error will occur. 
If you don't want the program to be forcibly terminated, you can handle this with exception handling. 
For reference, you can look up `FileNotFoundError` in Python's built-in exceptions.
```python
try:
    myfile = open("no_file")
except FileNotFoundError as e:
    print("An exception occurred.", e)
```
```python
An exception occurred. [Errno 2] No such file or directory: 'no_file'
```
{% include end-box.html %}

# 2.File I/O Using `with-as`
{% include start-box.html class="math-box"%}
You can use the `with-as` statement to avoid explicitly calling `close()`. 
Using `with-as` is generally more convenient. 
It automatically handles resource cleanup, which is why it's called a **_context manager_**.

```python
with open("myfile.txt", "r") as f:
    read_data = f.read()

    # f.closed: check if the file is closed
    print("File closed?", f.closed)

    print(read_data)

# When execution exits the 'with' block, f.close() is called automatically.
print("File closed?", f.closed) # Check the file state after the block

# Using 'with-as' ensures the file is open inside the block and closed outside.
```
```python
File closed? False
First line
Second line
Third line
File closed? True
```
{% include end-box.html %}

# 3.File I/O Methods
{% include start-box.html class="math-box"%}
## 3-1) `.read()`
The `.read()` method reads the entire content of the file and returns it as a single string.
```python
with open("myfile.txt", "r") as f:
    s = f.read()
print(s)
```
```python
First line
Second line
Third line
```
<br>
If you provide a number (size) to the `.read()` method, it reads that many characters. 
Subsequent calls to `.read()` will continue reading from where the last read stopped, not from the beginning.
```python
with open("myfile.txt", "r") as f:
    s = f.read(5) # Read first 2 characters
    print(s)

    s = f.read(5) # Read next 5 characters
    print(s)
```
```python
First
 line
```

## 3-2) `.readline()`
We can read the file line by line. 
Be aware that this method reads the newline character (`\n`) at the end of the line as well.
```python
with open("myfile.txt", "r") as f:
    s = f.readline()
    print(s)
```
```python
First line
```
<br>
`readline()` reads one line at a time.
If you don't know the file's length and want to read until the end, combine `while` and `readline()` to read all lines.
```python
with open("myfile.txt", "r") as f:
    while True:
        line = f.readline()
        if not line: # readline() returns an empty string at the end of the file
            break
        # Even with end="", a newline occurs because readline() includes '\n'.
        print(line, end="")
```
```python
First line
Second line
Third line
```
<br>
You can use the built-in string method `.rstrip()` to remove trailing whitespace (including the newline character) returned by `readline()`.
```python
with open("myfile.txt", "r") as f:
    while True:
        line = f.readline()
        if not line:
            break
        print(line.rstrip(), end="")
```
```python
First lineSecond lineThird line
```

## 3-3) `.readlines()`
You can read multiple lines of strings and return them as a `list`.
```python
# readlines() returns multiple lines as a list
with open("myfile.txt", "r") as f:
    lines = f.readlines()

print(type(lines))
print(lines)
```
```python
<class 'list'>
['First line\n', 'Second line\n', 'Third line']
```
{% include end-box.html %}

# 4.JSON Format
{% include start-box.html class="math-box"%}
**JSON (JavaScript Object Notation)** format is widely used for exchanging data over the internet. 
It is also often used for storing data. 
It corresponds well with Python's basic data types, making it convenient to use in Python. 
However, tuples are not directly supported.

## 4-1) Preserving Data During File I/O
If you convert a list to a string and save it in a `.txt` format, it can be difficult to restore it to its original list structure when you read it back.
```python
value = ["the answer", 42]

# Writing the list as a string
with open("my_list.txt", "wt") as f:
    s = str(value)
    f.write(s)

# Reading it back and trying to convert to a list
with open("my_list.txt", "rt") as f:
    read_data = f.read()

# This doesn't restore the original list structure
value = list(read_data)
print(value)
```
```python
['[', "'", 't', 'h', 'e', ' ', 'a', 'n', 's', 'w', 'e', 'r', "'", ',', ' ', '4', '2', ']']
```
<br>
Using JSON makes both saving and restoring easier.
- `json.dumps(dict, indent)`: Converts Python data (like dicts or lists) into a JSON string.

- `json.loads(str)`: Parses a JSON string and converts it back into Python data.

- `json.dump(dict, file_pointer)`: Writes Python data directly to a file-like object in JSON format.

- `json.load(file_pointer)`: Reads JSON data from a file-like object and converts it back into Python data. (Similar to `.read()` for text files).

```python
import json

value = ["the answer", 42.1, {"a": 1}]

# dumps can represent the object in string format.
print(f"{'Result of json.dumps():':<30}", json.dumps(value))
print(f"{'Type of json.dumps():':<30}", type(json.dumps(value)))

# Save to a file using dump()
with open("my_data.json", "wt") as f:
    json.dump(value, f)

# Read back from the file using load()
with open("my_data.json", "rt") as f:
    value = json.load(f)

print(f"{'Type of json.load():':<30}", type(value))
print(f"{'Types of items in json.load():':<30}", type(value[0]), type(value[1]), type(value[2]))

# You can check the contents are the same as what was saved.
print(f"{'Rerun result of json.load():':<30}", value)
```
```python
       Result of json.dumps(): ["the answer", 42.1, {"a": 1}]
         Type of json.dumps(): <class 'str'>
          Type of json.load(): <class 'list'>
Types of items in json.load(): <class 'str'> <class 'float'> <class 'dict'>
 Retrun result of json.load(): ['the answer', 42.1, {'a': 1}]
```
<br>
You can save the JSON in a more readable format by adding the `indent` parameter to the `dump()` or `dumps()` functions.
```python
print(json.dumps(value, indent = 2))
```
```python
[
  "the answer",
  42.1,
  {
    "a": 1
  }
]
```
{% include end-box.html %}

# 5.Binary Files
{% include start-box.html class="math-box"%}
Data inside a computer is fundamentally stored as sequences of binary digits (0s and 1s). It's possible to save this raw binary data directly to a file. Unlike text files, binary files are not intended to be directly read and understood by humans.

To open a file in binary mode, you add `b` to the mode string (e.g., `wb` for write binary, `rb` for read binary).

[Note] A binary digit (0 or 1) is called a bit. A group of 8 bits is called a byte.

```python
# Convert a string into a sequence of bytes (bytes).
# Use the encode() method to convert a string to bytes.
my_data = "Hello, World!".encode()

# You can also create a bytes literal directly by prefixing with 'b'.
# my_data = b"Hello, World!"

print(type(my_data))
print(my_data)

# wb: write binary
with open("my_data.bin", "wb") as f:
    # Data written in 'wb' mode must be bytes.
    f.write(my_data)

# rb: read binary
with open("my_data.bin", "rb") as f:
    # Data read in 'rb' mode is returned as bytes.
    read_data = f.read()

print(type(read_data))
print(read_data)

# Convert bytes back to a string
# Use the decode() method on the bytes object.
decoded_data = read_data.decode()
print(decoded_data)
```
```python
<class 'bytes'>
b'Hello, World!'
<class 'bytes'>
b'Hello, World!'
Hello, World!
```
{% include end-box.html %}


# 6.Pickle and Serialization
{% include start-box.html class="math-box"%}
**Serialization** is the process of converting an object into a format that can be easily stored in a file or transmitted over a network.

While computer memory itself is arranged linearly (a 1D structure), the data that makes up an object is often scattered across various memory locations. 
For example, in `value = ["the answer", 42.1]`, the container might be in one place, while the string object `"the answer"` and the float object `42.1` are stored elsewhere in memory. (Data Structures is the field that studies how to use these structures.)

Serialization is named so because it gathers this scattered data and arranges it into a single, linear sequence. 
The reverse process is called **deserialization**. 
It's convenient, like being able to save an object exactly as it is in memory and then restore it later. It's also frequently used for transmitting objects or data over a network.

In Python, the `pickle` module makes serialization and deserialization easy. 
These processes are called **pickling** and **unpickling**, respectively. 
You can easily save an object to a pickled file and then load it back to restore the original object. Files should be opened in **binary mode** (`wb` or `rb`).

Using pickle, you can simply save various data types to a single binary file. It's common practice to save large datasets as pickle files. The typical file extension is `.pkl`.

```python
import pickle

# The object to be pickled (can be complex)
value = ("the answer", 42.1, [{"a": 1}])

# Save the object to a binary file using pickle.dump()
with open("my_data.pkl", "wb") as f: # 'wb' means write binary
    pickle.dump(value, f)

# Load the object back from the binary file using pickle.load()
with open("my_data.pkl", "rb") as f: # 'rb' means read binary
    value = pickle.load(f)

# The original structure and types are restored after saving and reading.
print(value)
print(type(value[0]), type(value[1]), type(value[2][0]))
```
```python
('the answer', 42.1, [{'a': 1}])
<class 'str'> <class 'float'> <class 'dict'>
```
{% include end-box.html %}


# 7.Various I/O Modes
{% include start-box.html class="math-box"%}
When opening a file with the `open()` function, we can set various modes. 
We can see the full list of characters used for all settings here. 
We can also combine these characters. 
It's enough to know that these combinations are possible, even if you don't need to use all of them.

`rt`: Opens a text file for reading. If a file with the specified name doesn't exist, an error occurs because there is nothing to read. `r` is often sufficient as `t` is the default mode. If the mode is omitted entirely, `r` (which implies `rt`) is the default.

`wt`: Opens a text file for writing. If the file doesn't exist, it is created. If it does exist, its contents are erased (truncated).

`rb` and `wb`: These are the binary file equivalents of `rt` and `wt`, respectively.

`a` (append): Opens a file for appending. New data is added to the end of the file without erasing the existing contents.

`xt` or `xb` (exclusive creation): Opens a file for writing, but only if it does not already exist. If the file exists, an error occurs.
{% include end-box.html %}


# 8.Random Access
{% include start-box.html class="math-box"%}
When reading or writing content from a file, we can either process it sequentially from the beginning or access arbitrary positions within the file.

The `tell()` method tells us the current position where the next read or write operation will occur. Think of it like the blinking cursor in a text editor.

The `seek()` method allows us to move to a desired position within the file. `f.seek(offset, whence)`

- `offset`: The number of bytes to move.
- `whence`: Specifies the reference point for the move:
    - `0`: From the beginning of the file (default).
    - `1`: From the current position.
    - `2`: From the end of the file.

For example, `f.seek(3, 0)` means moving to the position 3 bytes away from the beginning of the file. The default value for `whence` is `0`.

```python
with open("myfile.txt") as f:
    # Get the current position
    # It's 0 initially because we haven't read anything yet.
    print(f.tell())

    # Move 2 bytes from the beginning of the file
    f.seek(2)
    print(f.tell())

    # Read 1 byte of data. 'c' will hold the data read.
    # After reading the data, tell() reflects the increased position.
    c = f.read(1)
    print(f.tell())
    print(c)
```
```python
0
2
3
r
```
<br>
We can also perform random access when reading files line by line.
```python
with open("myfile.txt") as f:
    f.seek(2) # Move to the 3rd byte (index 2)
    line = f.readline() # Reads from the current position to the next newline
    print(line)
```
```python
rst line
```
<br>
Random access is also possible when writing to a file.
```python
# Open in 'r+' mode for both reading and writing
with open("myfile.txt", "r+t") as f: 
    f.seek(3) # Move to the 4th byte (index 3)
    # This overwrites existing data, it doesn't insert.
    # The existing data is replaced by the new content.
    f.write("X")

with open("myfile.txt", "r") as f:
    s = f.readline()
    print(s)
```
```python
FirXt line
```
{% include end-box.html %}


# 9.File Encoding and Decoding
{% include start-box.html class="math-box"%}
Text files store characters by converting them into numbers. 
**Encoding** is the method that defines the mapping between characters and numbers. 
Different encoding standards exist, and the way characters are encoded depends on which standard is used.

When reading a text file, we must **decode** it using the same encoding method that was used when the file was created. 
This is particularly important when developing software intended for international use.

We can specify the encoding/decoding method when opening a text file.

```python
import locale

# You can check Python's default encoding like this.
# UTF-8 is commonly used.
locale.getpreferredencoding(False)
```
```python
'UTF-8'
```
<br>
An error will occur if the encoding used for writing the file is different from the encoding used for reading it.
```python
# Assuming 'myfile.txt' was saved using the default encoding (e.g., UTF-8).
# Trying to read it with a different encoding will cause an error.
try:
    with open("myfile.txt", "r", encoding = "utf-16") as f:
        s = f.read()
    print(s)
except UnicodeError as e:
    print(f"UnicodeError: {e}")
```
```python
---------------------------------------------------------------------------
UnicodeDecodeError                        Traceback (most recent call last)
Cell In[23], line 2
      1 with open("myfile.txt", "r", encoding = "utf-16") as f:
----> 2     s = f.read()
      4 print(s)

File d:\anaconda3\envs\Python_study\lib\codecs.py:322, in BufferedIncrementalDecoder.decode(self, input, final)
    319 def decode(self, input, final=False):
    320     # decode input (taking the buffer into account)
    321     data = self.buffer + input
--> 322     (result, consumed) = self._buffer_decode(data, self.errors, final)
    323     # keep undecoded input until the next call
    324     self.buffer = data[consumed:]

File d:\anaconda3\envs\Python_study\lib\encodings\utf_16.py:61, in IncrementalDecoder._buffer_decode(self, input, errors, final)
     58 def _buffer_decode(self, input, errors, final):
     59     if self.decoder is None:
     60         (output, consumed, byteorder) = \
---> 61             codecs.utf_16_ex_decode(input, errors, 0, final)
     62         if byteorder == -1:
     63             self.decoder = codecs.utf_16_le_decode

UnicodeDecodeError: 'utf-16-le' codec can't decode byte 0x65 in position 34: truncated data
```
{% include end-box.html %}


# 10.Checking File Existence
{% include start-box.html class="math-box"%}
Using the `isfile()` function from the `os.path` module, we can check whether a specified file exists in the current working directory.

```python
import os

# Check if a file named "no_file" exists
os.path.isfile("no_file")

# You can use 'if' to control the program's flow based on whether the file exists.
# Example:
# if os.path.isfile("my_data.txt"):
#     print("File exists.")
# else:
#     print("File does not exist.")
```
```python
False
```
{% include end-box.html %}


# 11.CSV Files
{% include start-box.html class="math-box"%}
We can easily perform input and output operations on **CSV** (Comma-Separated Values) files by importing the `csv` module.

```python
import csv

# When you read rows using DictReader, each row is turned into a dictionary.
# For each row, the column names (headers) become keys and the row's data become values.
dates = []
with open("Data.csv") as csv_file:
    # Read rows into dictionaries using the header row for keys.
    csv_reader = csv.DictReader(csv_file, delimiter=",")

    for row in csv_reader:
        # Example of accessing data by column header
        # dates.append(row["Date"])
        print(row) # Prints the dictionary for the current row
```
{% include end-box.html %}